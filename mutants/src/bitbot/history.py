"""This module handles the synchronization of Reddit post history."""

import os
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional

from .data.models import BotState, Config, GitHubRelease, RedditPost
from .interfaces.config_protocol import ConfigManagerProtocol
from .interfaces.github_protocol import GitHubManagerProtocol
from .interfaces.reddit_protocol import RedditManagerProtocol
from .interfaces.state_protocol import StateManagerProtocol
from .interfaces.template_protocol import TemplateManagerProtocol
from .logging import get_logger

logger = get_logger(__name__)
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg=None):
    """Forward call to original or mutated function, depending on the environment"""
    import os

    mutant_under_test = os.environ["MUTANT_UNDER_TEST"]
    if mutant_under_test == "fail":
        from mutmut.__main__ import MutmutProgrammaticFailException

        raise MutmutProgrammaticFailException("Failed programmatically")
    elif mutant_under_test == "stats":
        from mutmut.__main__ import record_trampoline_hit

        record_trampoline_hit(orig.__module__ + "." + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + "." + orig.__name__ + "__mutmut_"
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition(".")[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result


from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_yield_from_trampoline(orig, mutants, call_args, call_kwargs, self_arg=None):
    """Forward call to original or mutated function, depending on the environment"""
    import os

    mutant_under_test = os.environ["MUTANT_UNDER_TEST"]
    if mutant_under_test == "fail":
        from mutmut.__main__ import MutmutProgrammaticFailException

        raise MutmutProgrammaticFailException("Failed programmatically")
    elif mutant_under_test == "stats":
        from mutmut.__main__ import record_trampoline_hit

        record_trampoline_hit(orig.__module__ + "." + orig.__name__)
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + "." + orig.__name__ + "__mutmut_"
    if not mutant_under_test.startswith(prefix):
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition(".")[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = yield from mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = yield from mutants[mutant_name](*call_args, **call_kwargs)
    return result


async def x__get_latest_bot_release__mutmut_orig(
    github_manager: GitHubManagerProtocol, config: Config
) -> Optional[GitHubRelease]:
    """Get the latest bot release from GitHub."""
    return await github_manager.get_latest_release(config.github.botRepo)


async def x__get_latest_bot_release__mutmut_1(
    github_manager: GitHubManagerProtocol, config: Config
) -> Optional[GitHubRelease]:
    """Get the latest bot release from GitHub."""
    return await github_manager.get_latest_release(None)


x__get_latest_bot_release__mutmut_mutants: ClassVar[MutantDict] = {
    "x__get_latest_bot_release__mutmut_1": x__get_latest_bot_release__mutmut_1
}


def _get_latest_bot_release(*args, **kwargs):
    result = _mutmut_trampoline(
        x__get_latest_bot_release__mutmut_orig,
        x__get_latest_bot_release__mutmut_mutants,
        args,
        kwargs,
    )
    return result


_get_latest_bot_release.__signature__ = _mutmut_signature(
    x__get_latest_bot_release__mutmut_orig
)
x__get_latest_bot_release__mutmut_orig.__name__ = "x__get_latest_bot_release"


async def x__get_bot_posts_on_subreddit__mutmut_orig(
    reddit_manager: RedditManagerProtocol,
) -> List[RedditPost]:
    """Get all of the bot's release posts from the configured subreddit."""
    return await reddit_manager.get_recent_bot_posts(limit=100)


async def x__get_bot_posts_on_subreddit__mutmut_1(
    reddit_manager: RedditManagerProtocol,
) -> List[RedditPost]:
    """Get all of the bot's release posts from the configured subreddit."""
    return await reddit_manager.get_recent_bot_posts(limit=None)


async def x__get_bot_posts_on_subreddit__mutmut_2(
    reddit_manager: RedditManagerProtocol,
) -> List[RedditPost]:
    """Get all of the bot's release posts from the configured subreddit."""
    return await reddit_manager.get_recent_bot_posts(limit=101)


x__get_bot_posts_on_subreddit__mutmut_mutants: ClassVar[MutantDict] = {
    "x__get_bot_posts_on_subreddit__mutmut_1": x__get_bot_posts_on_subreddit__mutmut_1,
    "x__get_bot_posts_on_subreddit__mutmut_2": x__get_bot_posts_on_subreddit__mutmut_2,
}


def _get_bot_posts_on_subreddit(*args, **kwargs):
    result = _mutmut_trampoline(
        x__get_bot_posts_on_subreddit__mutmut_orig,
        x__get_bot_posts_on_subreddit__mutmut_mutants,
        args,
        kwargs,
    )
    return result


_get_bot_posts_on_subreddit.__signature__ = _mutmut_signature(
    x__get_bot_posts_on_subreddit__mutmut_orig
)
x__get_bot_posts_on_subreddit__mutmut_orig.__name__ = "x__get_bot_posts_on_subreddit"


def x__parse_version_from_title__mutmut_orig(title: str) -> str:
    """Parse the version from a post title."""
    match = re.search(r"v(\d+\.\d+\.\d+)", title)
    return match.group(1) if match else "0.0.0"


def x__parse_version_from_title__mutmut_1(title: str) -> str:
    """Parse the version from a post title."""
    match = None
    return match.group(1) if match else "0.0.0"


def x__parse_version_from_title__mutmut_2(title: str) -> str:
    """Parse the version from a post title."""
    match = re.search(None, title)
    return match.group(1) if match else "0.0.0"


def x__parse_version_from_title__mutmut_3(title: str) -> str:
    """Parse the version from a post title."""
    match = re.search(r"v(\d+\.\d+\.\d+)", None)
    return match.group(1) if match else "0.0.0"


def x__parse_version_from_title__mutmut_4(title: str) -> str:
    """Parse the version from a post title."""
    match = re.search(title)
    return match.group(1) if match else "0.0.0"


def x__parse_version_from_title__mutmut_5(title: str) -> str:
    """Parse the version from a post title."""
    match = re.search(
        r"v(\d+\.\d+\.\d+)",
    )
    return match.group(1) if match else "0.0.0"


def x__parse_version_from_title__mutmut_6(title: str) -> str:
    """Parse the version from a post title."""
    match = re.search(r"XXv(\d+\.\d+\.\d+)XX", title)
    return match.group(1) if match else "0.0.0"


def x__parse_version_from_title__mutmut_7(title: str) -> str:
    """Parse the version from a post title."""
    match = re.search(r"v(\d+\.\d+\.\d+)", title)
    return match.group(1) if match else "0.0.0"


def x__parse_version_from_title__mutmut_8(title: str) -> str:
    """Parse the version from a post title."""
    match = re.search(r"V(\D+\.\D+\.\D+)", title)
    return match.group(1) if match else "0.0.0"


def x__parse_version_from_title__mutmut_9(title: str) -> str:
    """Parse the version from a post title."""
    match = re.search(r"V(\d+\.\d+\.\d+)", title)
    return match.group(1) if match else "0.0.0"


def x__parse_version_from_title__mutmut_10(title: str) -> str:
    """Parse the version from a post title."""
    match = re.search(r"v(\d+\.\d+\.\d+)", title)
    return match.group(None) if match else "0.0.0"


def x__parse_version_from_title__mutmut_11(title: str) -> str:
    """Parse the version from a post title."""
    match = re.search(r"v(\d+\.\d+\.\d+)", title)
    return match.group(2) if match else "0.0.0"


def x__parse_version_from_title__mutmut_12(title: str) -> str:
    """Parse the version from a post title."""
    match = re.search(r"v(\d+\.\d+\.\d+)", title)
    return match.group(1) if match else "XX0.0.0XX"


x__parse_version_from_title__mutmut_mutants: ClassVar[MutantDict] = {
    "x__parse_version_from_title__mutmut_1": x__parse_version_from_title__mutmut_1,
    "x__parse_version_from_title__mutmut_2": x__parse_version_from_title__mutmut_2,
    "x__parse_version_from_title__mutmut_3": x__parse_version_from_title__mutmut_3,
    "x__parse_version_from_title__mutmut_4": x__parse_version_from_title__mutmut_4,
    "x__parse_version_from_title__mutmut_5": x__parse_version_from_title__mutmut_5,
    "x__parse_version_from_title__mutmut_6": x__parse_version_from_title__mutmut_6,
    "x__parse_version_from_title__mutmut_7": x__parse_version_from_title__mutmut_7,
    "x__parse_version_from_title__mutmut_8": x__parse_version_from_title__mutmut_8,
    "x__parse_version_from_title__mutmut_9": x__parse_version_from_title__mutmut_9,
    "x__parse_version_from_title__mutmut_10": x__parse_version_from_title__mutmut_10,
    "x__parse_version_from_title__mutmut_11": x__parse_version_from_title__mutmut_11,
    "x__parse_version_from_title__mutmut_12": x__parse_version_from_title__mutmut_12,
}


def _parse_version_from_title(*args, **kwargs):
    result = _mutmut_trampoline(
        x__parse_version_from_title__mutmut_orig,
        x__parse_version_from_title__mutmut_mutants,
        args,
        kwargs,
    )
    return result


_parse_version_from_title.__signature__ = _mutmut_signature(
    x__parse_version_from_title__mutmut_orig
)
x__parse_version_from_title__mutmut_orig.__name__ = "x__parse_version_from_title"


async def x__update_older_posts__mutmut_orig(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_1(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = None
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_2(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = None

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_3(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = None

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_4(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "XX{{latest_post_title}}XX": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_5(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{LATEST_POST_TITLE}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_6(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["XXtitleXX"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_7(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["TITLE"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_8(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["Title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_9(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "XX{{latest_post_url}}XX": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_10(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{LATEST_POST_URL}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_11(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["XXurlXX"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_12(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["URL"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_13(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["Url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_14(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "XX{{latest_version}}XX": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_15(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{LATEST_VERSION}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_16(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["XXversionXX"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_17(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["VERSION"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_18(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["Version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_19(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "XX{{latest_download_url}}XX": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_20(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{LATEST_DOWNLOAD_URL}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_21(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["XXdirect_download_urlXX"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_22(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["DIRECT_DOWNLOAD_URL"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_23(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["Direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_24(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "XX{{asset_name}}XX": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_25(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{ASSET_NAME}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_26(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "XX{{bot_name}}XX": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_27(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{BOT_NAME}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_28(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "XX{{bot_repo}}XX": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_29(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{BOT_REPO}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_30(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode != "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_31(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "XXinjectXX":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_32(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "INJECT":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_33(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "Inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_34(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = None
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_35(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = None

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_36(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(None)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_37(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = None
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_38(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = None
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_39(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker or end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_40(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker or start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_41(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker not in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_42(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = None
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_43(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(None, re.DOTALL)
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_44(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", None
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_45(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(re.DOTALL)
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_46(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}",
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_47(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(None)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_48(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(None)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_49(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = None
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_50(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(None, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_51(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, None, raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_52(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", None).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_53(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub("", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_54(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_55(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(
                pattern,
                "",
            ).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_56(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "XXXX", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_57(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = None

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_58(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = None
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_59(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "XX## ⚠️ Outdated PostXX"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_60(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ outdated post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_61(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ OUTDATED POST"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_62(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ outdated post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_63(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = None
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_64(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = None

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_65(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(None, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_66(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, None)

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_67(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_68(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(
                placeholder,
            )

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_69(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(None))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_70(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = None
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_71(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 1
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_72(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = None
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_73(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = None

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_74(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = "XXXX"

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_75(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string not in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_76(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info(None, old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_77(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", None)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_78(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info(old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_79(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info(
                        "Replacing outdated banner in post %s.",
                    )
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_80(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info(
                        "XXReplacing outdated banner in post %s.XX", old_post.id
                    )
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_81(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_82(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("REPLACING OUTDATED BANNER IN POST %S.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_83(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = None
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_84(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        None,
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_85(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        None,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_86(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_87(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_88(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(None)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_89(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL & re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_90(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = None
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_91(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(None, original_body, 1)
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_92(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(f"{injection_banner}\n\n---", None, 1)
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_93(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, None
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_94(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(original_body, 1)
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_95(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(f"{injection_banner}\n\n---", 1)
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_96(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---",
                        original_body,
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_97(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 2
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_98(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(None, old_post.id)
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_99(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info("Injecting new outdated banner into post %s.", None)
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_100(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(old_post.id)
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_101(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.",
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_102(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "XXInjecting new outdated banner into post %s.XX", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_103(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_104(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "INJECTING NEW OUTDATED BANNER INTO POST %S.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_105(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = None

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_106(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() or new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_107(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body == original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_108(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(None, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_109(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, None)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_110(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_111(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(
                        old_post.id,
                    )
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_112(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count = 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_113(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count -= 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_114(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 2
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_115(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info(None, old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_116(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", None)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_117(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info(old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_118(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info(
                        "Post %s did not need updating.",
                    )

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_119(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("XXPost %s did not need updating.XX", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_120(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_121(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("POST %S DID NOT NEED UPDATING.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_122(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(None, old_post.id, exc_info=True)

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_123(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", None, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_124(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=None
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_125(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(old_post.id, exc_info=True)

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_126(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning("Failed to update banner in post %s.", exc_info=True)

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_127(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.",
                    old_post.id,
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_128(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "XXFailed to update banner in post %s.XX",
                    old_post.id,
                    exc_info=True,
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_129(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_130(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "FAILED TO UPDATE BANNER IN POST %S.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_131(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=False
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_132(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count >= 0:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_133(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 1:
            logger.info("Successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_134(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info(None, updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_135(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("Successfully updated banner in %s older posts.", None)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_136(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info(updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_137(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info(
                "Successfully updated banner in %s older posts.",
            )
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_138(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info(
                "XXSuccessfully updated banner in %s older posts.XX", updated_count
            )
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_139(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("successfully updated banner in %s older posts.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


async def x__update_older_posts__mutmut_140(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    older_posts: List[RedditPost],
    latest_release_details: Dict[str, str],
    config: Config,
) -> None:
    """Update older posts with a banner pointing to the latest release."""
    handling_config = config.outdatedPostHandling
    mode = handling_config.mode

    placeholders = {
        "{{latest_post_title}}": latest_release_details["title"],
        "{{latest_post_url}}": latest_release_details["url"],
        "{{latest_version}}": latest_release_details["version"],
        "{{latest_download_url}}": latest_release_details["direct_download_url"],
        "{{asset_name}}": config.github.assetFileName,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
    }

    if mode == "inject":
        template_path = handling_config.injectTemplateFile
        raw_template = await template_manager.get_template(template_path)

        ignore_block = config.skipContent
        start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
        if start_marker and end_marker and start_marker in raw_template:
            pattern = re.compile(
                f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
            )
            banner_template = re.sub(pattern, "", raw_template).strip()
        else:
            banner_template = raw_template

        existence_check_string = "## ⚠️ Outdated Post"
        injection_banner = banner_template
        for placeholder, value in placeholders.items():
            injection_banner = injection_banner.replace(placeholder, str(value))

        updated_count = 0
        for old_post in older_posts:
            original_body = old_post.body
            new_body = ""

            try:
                if existence_check_string in original_body:
                    logger.info("Replacing outdated banner in post %s.", old_post.id)
                    pattern = re.compile(
                        f"^{re.escape(existence_check_string)}.*?---",
                        re.DOTALL | re.MULTILINE,
                    )
                    new_body = pattern.sub(
                        f"{injection_banner}\n\n---", original_body, 1
                    )
                else:
                    logger.info(
                        "Injecting new outdated banner into post %s.", old_post.id
                    )
                    new_body = f"{injection_banner}\n\n---\n\n{original_body}"

                if new_body.strip() and new_body != original_body:
                    await reddit_manager.update_post_body(old_post.id, new_body)
                    updated_count += 1
                else:
                    logger.info("Post %s did not need updating.", old_post.id)

            except Exception:
                logger.warning(
                    "Failed to update banner in post %s.", old_post.id, exc_info=True
                )

        if updated_count > 0:
            logger.info("SUCCESSFULLY UPDATED BANNER IN %S OLDER POSTS.", updated_count)
    else:  # Overwrite mode
        # ... (This logic is fine)
        pass


x__update_older_posts__mutmut_mutants: ClassVar[MutantDict] = {
    "x__update_older_posts__mutmut_1": x__update_older_posts__mutmut_1,
    "x__update_older_posts__mutmut_2": x__update_older_posts__mutmut_2,
    "x__update_older_posts__mutmut_3": x__update_older_posts__mutmut_3,
    "x__update_older_posts__mutmut_4": x__update_older_posts__mutmut_4,
    "x__update_older_posts__mutmut_5": x__update_older_posts__mutmut_5,
    "x__update_older_posts__mutmut_6": x__update_older_posts__mutmut_6,
    "x__update_older_posts__mutmut_7": x__update_older_posts__mutmut_7,
    "x__update_older_posts__mutmut_8": x__update_older_posts__mutmut_8,
    "x__update_older_posts__mutmut_9": x__update_older_posts__mutmut_9,
    "x__update_older_posts__mutmut_10": x__update_older_posts__mutmut_10,
    "x__update_older_posts__mutmut_11": x__update_older_posts__mutmut_11,
    "x__update_older_posts__mutmut_12": x__update_older_posts__mutmut_12,
    "x__update_older_posts__mutmut_13": x__update_older_posts__mutmut_13,
    "x__update_older_posts__mutmut_14": x__update_older_posts__mutmut_14,
    "x__update_older_posts__mutmut_15": x__update_older_posts__mutmut_15,
    "x__update_older_posts__mutmut_16": x__update_older_posts__mutmut_16,
    "x__update_older_posts__mutmut_17": x__update_older_posts__mutmut_17,
    "x__update_older_posts__mutmut_18": x__update_older_posts__mutmut_18,
    "x__update_older_posts__mutmut_19": x__update_older_posts__mutmut_19,
    "x__update_older_posts__mutmut_20": x__update_older_posts__mutmut_20,
    "x__update_older_posts__mutmut_21": x__update_older_posts__mutmut_21,
    "x__update_older_posts__mutmut_22": x__update_older_posts__mutmut_22,
    "x__update_older_posts__mutmut_23": x__update_older_posts__mutmut_23,
    "x__update_older_posts__mutmut_24": x__update_older_posts__mutmut_24,
    "x__update_older_posts__mutmut_25": x__update_older_posts__mutmut_25,
    "x__update_older_posts__mutmut_26": x__update_older_posts__mutmut_26,
    "x__update_older_posts__mutmut_27": x__update_older_posts__mutmut_27,
    "x__update_older_posts__mutmut_28": x__update_older_posts__mutmut_28,
    "x__update_older_posts__mutmut_29": x__update_older_posts__mutmut_29,
    "x__update_older_posts__mutmut_30": x__update_older_posts__mutmut_30,
    "x__update_older_posts__mutmut_31": x__update_older_posts__mutmut_31,
    "x__update_older_posts__mutmut_32": x__update_older_posts__mutmut_32,
    "x__update_older_posts__mutmut_33": x__update_older_posts__mutmut_33,
    "x__update_older_posts__mutmut_34": x__update_older_posts__mutmut_34,
    "x__update_older_posts__mutmut_35": x__update_older_posts__mutmut_35,
    "x__update_older_posts__mutmut_36": x__update_older_posts__mutmut_36,
    "x__update_older_posts__mutmut_37": x__update_older_posts__mutmut_37,
    "x__update_older_posts__mutmut_38": x__update_older_posts__mutmut_38,
    "x__update_older_posts__mutmut_39": x__update_older_posts__mutmut_39,
    "x__update_older_posts__mutmut_40": x__update_older_posts__mutmut_40,
    "x__update_older_posts__mutmut_41": x__update_older_posts__mutmut_41,
    "x__update_older_posts__mutmut_42": x__update_older_posts__mutmut_42,
    "x__update_older_posts__mutmut_43": x__update_older_posts__mutmut_43,
    "x__update_older_posts__mutmut_44": x__update_older_posts__mutmut_44,
    "x__update_older_posts__mutmut_45": x__update_older_posts__mutmut_45,
    "x__update_older_posts__mutmut_46": x__update_older_posts__mutmut_46,
    "x__update_older_posts__mutmut_47": x__update_older_posts__mutmut_47,
    "x__update_older_posts__mutmut_48": x__update_older_posts__mutmut_48,
    "x__update_older_posts__mutmut_49": x__update_older_posts__mutmut_49,
    "x__update_older_posts__mutmut_50": x__update_older_posts__mutmut_50,
    "x__update_older_posts__mutmut_51": x__update_older_posts__mutmut_51,
    "x__update_older_posts__mutmut_52": x__update_older_posts__mutmut_52,
    "x__update_older_posts__mutmut_53": x__update_older_posts__mutmut_53,
    "x__update_older_posts__mutmut_54": x__update_older_posts__mutmut_54,
    "x__update_older_posts__mutmut_55": x__update_older_posts__mutmut_55,
    "x__update_older_posts__mutmut_56": x__update_older_posts__mutmut_56,
    "x__update_older_posts__mutmut_57": x__update_older_posts__mutmut_57,
    "x__update_older_posts__mutmut_58": x__update_older_posts__mutmut_58,
    "x__update_older_posts__mutmut_59": x__update_older_posts__mutmut_59,
    "x__update_older_posts__mutmut_60": x__update_older_posts__mutmut_60,
    "x__update_older_posts__mutmut_61": x__update_older_posts__mutmut_61,
    "x__update_older_posts__mutmut_62": x__update_older_posts__mutmut_62,
    "x__update_older_posts__mutmut_63": x__update_older_posts__mutmut_63,
    "x__update_older_posts__mutmut_64": x__update_older_posts__mutmut_64,
    "x__update_older_posts__mutmut_65": x__update_older_posts__mutmut_65,
    "x__update_older_posts__mutmut_66": x__update_older_posts__mutmut_66,
    "x__update_older_posts__mutmut_67": x__update_older_posts__mutmut_67,
    "x__update_older_posts__mutmut_68": x__update_older_posts__mutmut_68,
    "x__update_older_posts__mutmut_69": x__update_older_posts__mutmut_69,
    "x__update_older_posts__mutmut_70": x__update_older_posts__mutmut_70,
    "x__update_older_posts__mutmut_71": x__update_older_posts__mutmut_71,
    "x__update_older_posts__mutmut_72": x__update_older_posts__mutmut_72,
    "x__update_older_posts__mutmut_73": x__update_older_posts__mutmut_73,
    "x__update_older_posts__mutmut_74": x__update_older_posts__mutmut_74,
    "x__update_older_posts__mutmut_75": x__update_older_posts__mutmut_75,
    "x__update_older_posts__mutmut_76": x__update_older_posts__mutmut_76,
    "x__update_older_posts__mutmut_77": x__update_older_posts__mutmut_77,
    "x__update_older_posts__mutmut_78": x__update_older_posts__mutmut_78,
    "x__update_older_posts__mutmut_79": x__update_older_posts__mutmut_79,
    "x__update_older_posts__mutmut_80": x__update_older_posts__mutmut_80,
    "x__update_older_posts__mutmut_81": x__update_older_posts__mutmut_81,
    "x__update_older_posts__mutmut_82": x__update_older_posts__mutmut_82,
    "x__update_older_posts__mutmut_83": x__update_older_posts__mutmut_83,
    "x__update_older_posts__mutmut_84": x__update_older_posts__mutmut_84,
    "x__update_older_posts__mutmut_85": x__update_older_posts__mutmut_85,
    "x__update_older_posts__mutmut_86": x__update_older_posts__mutmut_86,
    "x__update_older_posts__mutmut_87": x__update_older_posts__mutmut_87,
    "x__update_older_posts__mutmut_88": x__update_older_posts__mutmut_88,
    "x__update_older_posts__mutmut_89": x__update_older_posts__mutmut_89,
    "x__update_older_posts__mutmut_90": x__update_older_posts__mutmut_90,
    "x__update_older_posts__mutmut_91": x__update_older_posts__mutmut_91,
    "x__update_older_posts__mutmut_92": x__update_older_posts__mutmut_92,
    "x__update_older_posts__mutmut_93": x__update_older_posts__mutmut_93,
    "x__update_older_posts__mutmut_94": x__update_older_posts__mutmut_94,
    "x__update_older_posts__mutmut_95": x__update_older_posts__mutmut_95,
    "x__update_older_posts__mutmut_96": x__update_older_posts__mutmut_96,
    "x__update_older_posts__mutmut_97": x__update_older_posts__mutmut_97,
    "x__update_older_posts__mutmut_98": x__update_older_posts__mutmut_98,
    "x__update_older_posts__mutmut_99": x__update_older_posts__mutmut_99,
    "x__update_older_posts__mutmut_100": x__update_older_posts__mutmut_100,
    "x__update_older_posts__mutmut_101": x__update_older_posts__mutmut_101,
    "x__update_older_posts__mutmut_102": x__update_older_posts__mutmut_102,
    "x__update_older_posts__mutmut_103": x__update_older_posts__mutmut_103,
    "x__update_older_posts__mutmut_104": x__update_older_posts__mutmut_104,
    "x__update_older_posts__mutmut_105": x__update_older_posts__mutmut_105,
    "x__update_older_posts__mutmut_106": x__update_older_posts__mutmut_106,
    "x__update_older_posts__mutmut_107": x__update_older_posts__mutmut_107,
    "x__update_older_posts__mutmut_108": x__update_older_posts__mutmut_108,
    "x__update_older_posts__mutmut_109": x__update_older_posts__mutmut_109,
    "x__update_older_posts__mutmut_110": x__update_older_posts__mutmut_110,
    "x__update_older_posts__mutmut_111": x__update_older_posts__mutmut_111,
    "x__update_older_posts__mutmut_112": x__update_older_posts__mutmut_112,
    "x__update_older_posts__mutmut_113": x__update_older_posts__mutmut_113,
    "x__update_older_posts__mutmut_114": x__update_older_posts__mutmut_114,
    "x__update_older_posts__mutmut_115": x__update_older_posts__mutmut_115,
    "x__update_older_posts__mutmut_116": x__update_older_posts__mutmut_116,
    "x__update_older_posts__mutmut_117": x__update_older_posts__mutmut_117,
    "x__update_older_posts__mutmut_118": x__update_older_posts__mutmut_118,
    "x__update_older_posts__mutmut_119": x__update_older_posts__mutmut_119,
    "x__update_older_posts__mutmut_120": x__update_older_posts__mutmut_120,
    "x__update_older_posts__mutmut_121": x__update_older_posts__mutmut_121,
    "x__update_older_posts__mutmut_122": x__update_older_posts__mutmut_122,
    "x__update_older_posts__mutmut_123": x__update_older_posts__mutmut_123,
    "x__update_older_posts__mutmut_124": x__update_older_posts__mutmut_124,
    "x__update_older_posts__mutmut_125": x__update_older_posts__mutmut_125,
    "x__update_older_posts__mutmut_126": x__update_older_posts__mutmut_126,
    "x__update_older_posts__mutmut_127": x__update_older_posts__mutmut_127,
    "x__update_older_posts__mutmut_128": x__update_older_posts__mutmut_128,
    "x__update_older_posts__mutmut_129": x__update_older_posts__mutmut_129,
    "x__update_older_posts__mutmut_130": x__update_older_posts__mutmut_130,
    "x__update_older_posts__mutmut_131": x__update_older_posts__mutmut_131,
    "x__update_older_posts__mutmut_132": x__update_older_posts__mutmut_132,
    "x__update_older_posts__mutmut_133": x__update_older_posts__mutmut_133,
    "x__update_older_posts__mutmut_134": x__update_older_posts__mutmut_134,
    "x__update_older_posts__mutmut_135": x__update_older_posts__mutmut_135,
    "x__update_older_posts__mutmut_136": x__update_older_posts__mutmut_136,
    "x__update_older_posts__mutmut_137": x__update_older_posts__mutmut_137,
    "x__update_older_posts__mutmut_138": x__update_older_posts__mutmut_138,
    "x__update_older_posts__mutmut_139": x__update_older_posts__mutmut_139,
    "x__update_older_posts__mutmut_140": x__update_older_posts__mutmut_140,
}


def _update_older_posts(*args, **kwargs):
    result = _mutmut_trampoline(
        x__update_older_posts__mutmut_orig,
        x__update_older_posts__mutmut_mutants,
        args,
        kwargs,
    )
    return result


_update_older_posts.__signature__ = _mutmut_signature(
    x__update_older_posts__mutmut_orig
)
x__update_older_posts__mutmut_orig.__name__ = "x__update_older_posts"


async def x__update_bot_state__mutmut_orig(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_1(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = None
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_2(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=None,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_3(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp=None,
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_4(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=None,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_5(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=None,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_6(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_7(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_8(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_9(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_10(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="XX2024-01-01T00:00:00ZXX",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_11(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01t00:00:00z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_12(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01t00:00:00z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_13(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=1,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_14(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(None)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_15(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info(None, post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_16(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", None)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_17(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info(post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_18(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info(
        "State file updated. Now monitoring post: %s",
    )
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_19(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("XXState file updated. Now monitoring post: %sXX", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_20(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("state file updated. now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_21(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("STATE FILE UPDATED. NOW MONITORING POST: %S", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_22(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_23(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = None
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_24(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get(None, "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_25(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", None)
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_26(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_27(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get(
        "GITHUB_OUTPUT",
    )
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_28(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("XXGITHUB_OUTPUTXX", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_29(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("github_output", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_30(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("Github_output", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_31(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "XX/dev/nullXX")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_32(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/DEV/NULL")
    with Path(github_output).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_33(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open(None) as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_34(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(None).open("a") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_35(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("XXaXX") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_36(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("A") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_37(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("A") as f:
        f.write("state_changed=true")


async def x__update_bot_state__mutmut_38(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write(None)


async def x__update_bot_state__mutmut_39(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("XXstate_changed=trueXX")


async def x__update_bot_state__mutmut_40(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("STATE_CHANGED=TRUE")


async def x__update_bot_state__mutmut_41(
    state_manager: StateManagerProtocol, post_id: str, config: Config
) -> None:
    """Update the bot's state file."""
    new_state = BotState(
        activePostId=post_id,
        lastCheckTimestamp="2024-01-01T00:00:00Z",
        currentIntervalSeconds=config.timing.firstCheck,
        lastCommentCount=0,
    )
    await state_manager.save_state(new_state)
    logger.info("State file updated. Now monitoring post: %s", post_id)
    github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
    with Path(github_output).open("a") as f:
        f.write("State_changed=true")


x__update_bot_state__mutmut_mutants: ClassVar[MutantDict] = {
    "x__update_bot_state__mutmut_1": x__update_bot_state__mutmut_1,
    "x__update_bot_state__mutmut_2": x__update_bot_state__mutmut_2,
    "x__update_bot_state__mutmut_3": x__update_bot_state__mutmut_3,
    "x__update_bot_state__mutmut_4": x__update_bot_state__mutmut_4,
    "x__update_bot_state__mutmut_5": x__update_bot_state__mutmut_5,
    "x__update_bot_state__mutmut_6": x__update_bot_state__mutmut_6,
    "x__update_bot_state__mutmut_7": x__update_bot_state__mutmut_7,
    "x__update_bot_state__mutmut_8": x__update_bot_state__mutmut_8,
    "x__update_bot_state__mutmut_9": x__update_bot_state__mutmut_9,
    "x__update_bot_state__mutmut_10": x__update_bot_state__mutmut_10,
    "x__update_bot_state__mutmut_11": x__update_bot_state__mutmut_11,
    "x__update_bot_state__mutmut_12": x__update_bot_state__mutmut_12,
    "x__update_bot_state__mutmut_13": x__update_bot_state__mutmut_13,
    "x__update_bot_state__mutmut_14": x__update_bot_state__mutmut_14,
    "x__update_bot_state__mutmut_15": x__update_bot_state__mutmut_15,
    "x__update_bot_state__mutmut_16": x__update_bot_state__mutmut_16,
    "x__update_bot_state__mutmut_17": x__update_bot_state__mutmut_17,
    "x__update_bot_state__mutmut_18": x__update_bot_state__mutmut_18,
    "x__update_bot_state__mutmut_19": x__update_bot_state__mutmut_19,
    "x__update_bot_state__mutmut_20": x__update_bot_state__mutmut_20,
    "x__update_bot_state__mutmut_21": x__update_bot_state__mutmut_21,
    "x__update_bot_state__mutmut_22": x__update_bot_state__mutmut_22,
    "x__update_bot_state__mutmut_23": x__update_bot_state__mutmut_23,
    "x__update_bot_state__mutmut_24": x__update_bot_state__mutmut_24,
    "x__update_bot_state__mutmut_25": x__update_bot_state__mutmut_25,
    "x__update_bot_state__mutmut_26": x__update_bot_state__mutmut_26,
    "x__update_bot_state__mutmut_27": x__update_bot_state__mutmut_27,
    "x__update_bot_state__mutmut_28": x__update_bot_state__mutmut_28,
    "x__update_bot_state__mutmut_29": x__update_bot_state__mutmut_29,
    "x__update_bot_state__mutmut_30": x__update_bot_state__mutmut_30,
    "x__update_bot_state__mutmut_31": x__update_bot_state__mutmut_31,
    "x__update_bot_state__mutmut_32": x__update_bot_state__mutmut_32,
    "x__update_bot_state__mutmut_33": x__update_bot_state__mutmut_33,
    "x__update_bot_state__mutmut_34": x__update_bot_state__mutmut_34,
    "x__update_bot_state__mutmut_35": x__update_bot_state__mutmut_35,
    "x__update_bot_state__mutmut_36": x__update_bot_state__mutmut_36,
    "x__update_bot_state__mutmut_37": x__update_bot_state__mutmut_37,
    "x__update_bot_state__mutmut_38": x__update_bot_state__mutmut_38,
    "x__update_bot_state__mutmut_39": x__update_bot_state__mutmut_39,
    "x__update_bot_state__mutmut_40": x__update_bot_state__mutmut_40,
    "x__update_bot_state__mutmut_41": x__update_bot_state__mutmut_41,
}


def _update_bot_state(*args, **kwargs):
    result = _mutmut_trampoline(
        x__update_bot_state__mutmut_orig,
        x__update_bot_state__mutmut_mutants,
        args,
        kwargs,
    )
    return result


_update_bot_state.__signature__ = _mutmut_signature(x__update_bot_state__mutmut_orig)
x__update_bot_state__mutmut_orig.__name__ = "x__update_bot_state"


async def x__post_new_release__mutmut_orig(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_1(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = None

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_2(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(None)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_3(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = None
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_4(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = None
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_5(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker or end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_6(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker or start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_7(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker not in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_8(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = None
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_9(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(None, re.DOTALL)
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_10(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", None
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_11(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(re.DOTALL)
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_12(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}",
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_13(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(f"{re.escape(None)}.*?{re.escape(end_marker)}", re.DOTALL)
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_14(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(None)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_15(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = None
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_16(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(None, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_17(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, None, raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_18(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", None)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_19(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub("", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_20(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_21(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(
            pattern,
            "",
        )
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_22(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "XXXX", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_23(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = None

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_24(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = None
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_25(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "XX## ⚠️ Outdated PostXX"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_26(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ outdated post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_27(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ OUTDATED POST"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_28(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ outdated post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_29(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string not in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_30(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(None)
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_31(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "XXThe main post template contained an 'Outdated Post' banner. XX"
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_32(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "the main post template contained an 'outdated post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_33(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "THE MAIN POST TEMPLATE CONTAINED AN 'OUTDATED POST' BANNER. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_34(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'outdated post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_35(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "XXIt has been automatically removed.XX"
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_36(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "it has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_37(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "IT HAS BEEN AUTOMATICALLY REMOVED."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_38(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = None
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_39(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(None, re.DOTALL | re.MULTILINE)
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_40(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(f"^{re.escape(existence_check_string)}.*?---", None)
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_41(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(re.DOTALL | re.MULTILINE)
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_42(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---",
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_43(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(None)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_44(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL & re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_45(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = None
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_46(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub(None, clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_47(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", None).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_48(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub(clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_49(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub(
            "",
        ).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_50(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("XXXX", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_51(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = None

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_52(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = None
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_53(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        None, config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_54(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace("{{status}}", None)
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_55(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_56(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}",
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_57(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "XX{{status}}XX", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_58(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{STATUS}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_59(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = None

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_60(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "XX{{version}}XX": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_61(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{VERSION}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_62(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "XX{{direct_download_url}}XX": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_63(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{DIRECT_DOWNLOAD_URL}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_64(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "XX{{bot_name}}XX": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_65(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{BOT_NAME}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_66(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "XX{{bot_repo}}XX": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_67(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{BOT_REPO}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_68(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "XX{{asset_name}}XX": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_69(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{ASSET_NAME}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_70(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "XX{{creator_username}}XX": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_71(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{CREATOR_USERNAME}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_72(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "XX{{initial_status}}XX": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_73(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{INITIAL_STATUS}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_74(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = None
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_75(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = None
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_76(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = None
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_77(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(None, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_78(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, None)
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_79(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_80(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(
            placeholder,
        )
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_81(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(None))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_82(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = None

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_83(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(None, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_84(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, None)

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_85(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_86(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(
            placeholder,
        )

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_87(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(None))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_88(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        None,
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_89(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        None,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_90(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        None,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_91(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_92(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_93(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_94(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "XXSubmitting new post for v%s to r/%s...XX",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_95(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_96(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "SUBMITTING NEW POST FOR V%S TO R/%S...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_97(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = None
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_98(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(None, post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_99(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, None)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_100(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(post_body)
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_101(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(
        title,
    )
    logger.info("Post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_102(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info(None, submission.url)
    return submission


async def x__post_new_release__mutmut_103(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("Post successful: %s", None)
    return submission


async def x__post_new_release__mutmut_104(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info(submission.url)
    return submission


async def x__post_new_release__mutmut_105(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info(
        "Post successful: %s",
    )
    return submission


async def x__post_new_release__mutmut_106(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("XXPost successful: %sXX", submission.url)
    return submission


async def x__post_new_release__mutmut_107(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("post successful: %s", submission.url)
    return submission


async def x__post_new_release__mutmut_108(
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
    version: str,
    direct_download_url: str,
    config: Config,
) -> RedditPost:
    """Post a new release to Reddit."""
    raw_template = await template_manager.get_template(config.reddit.templateFile)

    ignore_block = config.skipContent
    start_marker, end_marker = ignore_block.startTag, ignore_block.endTag
    if start_marker and end_marker and start_marker in raw_template:
        pattern = re.compile(
            f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL
        )
        clean_template = re.sub(pattern, "", raw_template)
    else:
        clean_template = raw_template

    existence_check_string = "## ⚠️ Outdated Post"
    if existence_check_string in clean_template:
        logger.warning(
            "The main post template contained an 'Outdated Post' banner. "
            "It has been automatically removed."
        )
        banner_pattern = re.compile(
            f"^{re.escape(existence_check_string)}.*?---", re.DOTALL | re.MULTILINE
        )
        post_body_template = banner_pattern.sub("", clean_template).strip()
    else:
        post_body_template = clean_template.strip()

    initial_status_line = config.feedback.statusLineFormat.replace(
        "{{status}}", config.feedback.labels.unknown
    )
    placeholders = {
        "{{version}}": version,
        "{{direct_download_url}}": direct_download_url,
        "{{bot_name}}": config.reddit.botName,
        "{{bot_repo}}": config.github.botRepo,
        "{{asset_name}}": config.github.assetFileName,
        "{{creator_username}}": config.reddit.creator,
        "{{initial_status}}": initial_status_line,
    }

    title = config.reddit.postTitle
    post_body = post_body_template
    for placeholder, value in placeholders.items():
        post_body = post_body.replace(placeholder, str(value))
        title = title.replace(placeholder, str(value))

    logger.info(
        "Submitting new post for v%s to r/%s...",
        version,
        config.reddit.subreddit,
    )
    submission = await reddit_manager.submit_post(title, post_body)
    logger.info("POST SUCCESSFUL: %S", submission.url)
    return submission


x__post_new_release__mutmut_mutants: ClassVar[MutantDict] = {
    "x__post_new_release__mutmut_1": x__post_new_release__mutmut_1,
    "x__post_new_release__mutmut_2": x__post_new_release__mutmut_2,
    "x__post_new_release__mutmut_3": x__post_new_release__mutmut_3,
    "x__post_new_release__mutmut_4": x__post_new_release__mutmut_4,
    "x__post_new_release__mutmut_5": x__post_new_release__mutmut_5,
    "x__post_new_release__mutmut_6": x__post_new_release__mutmut_6,
    "x__post_new_release__mutmut_7": x__post_new_release__mutmut_7,
    "x__post_new_release__mutmut_8": x__post_new_release__mutmut_8,
    "x__post_new_release__mutmut_9": x__post_new_release__mutmut_9,
    "x__post_new_release__mutmut_10": x__post_new_release__mutmut_10,
    "x__post_new_release__mutmut_11": x__post_new_release__mutmut_11,
    "x__post_new_release__mutmut_12": x__post_new_release__mutmut_12,
    "x__post_new_release__mutmut_13": x__post_new_release__mutmut_13,
    "x__post_new_release__mutmut_14": x__post_new_release__mutmut_14,
    "x__post_new_release__mutmut_15": x__post_new_release__mutmut_15,
    "x__post_new_release__mutmut_16": x__post_new_release__mutmut_16,
    "x__post_new_release__mutmut_17": x__post_new_release__mutmut_17,
    "x__post_new_release__mutmut_18": x__post_new_release__mutmut_18,
    "x__post_new_release__mutmut_19": x__post_new_release__mutmut_19,
    "x__post_new_release__mutmut_20": x__post_new_release__mutmut_20,
    "x__post_new_release__mutmut_21": x__post_new_release__mutmut_21,
    "x__post_new_release__mutmut_22": x__post_new_release__mutmut_22,
    "x__post_new_release__mutmut_23": x__post_new_release__mutmut_23,
    "x__post_new_release__mutmut_24": x__post_new_release__mutmut_24,
    "x__post_new_release__mutmut_25": x__post_new_release__mutmut_25,
    "x__post_new_release__mutmut_26": x__post_new_release__mutmut_26,
    "x__post_new_release__mutmut_27": x__post_new_release__mutmut_27,
    "x__post_new_release__mutmut_28": x__post_new_release__mutmut_28,
    "x__post_new_release__mutmut_29": x__post_new_release__mutmut_29,
    "x__post_new_release__mutmut_30": x__post_new_release__mutmut_30,
    "x__post_new_release__mutmut_31": x__post_new_release__mutmut_31,
    "x__post_new_release__mutmut_32": x__post_new_release__mutmut_32,
    "x__post_new_release__mutmut_33": x__post_new_release__mutmut_33,
    "x__post_new_release__mutmut_34": x__post_new_release__mutmut_34,
    "x__post_new_release__mutmut_35": x__post_new_release__mutmut_35,
    "x__post_new_release__mutmut_36": x__post_new_release__mutmut_36,
    "x__post_new_release__mutmut_37": x__post_new_release__mutmut_37,
    "x__post_new_release__mutmut_38": x__post_new_release__mutmut_38,
    "x__post_new_release__mutmut_39": x__post_new_release__mutmut_39,
    "x__post_new_release__mutmut_40": x__post_new_release__mutmut_40,
    "x__post_new_release__mutmut_41": x__post_new_release__mutmut_41,
    "x__post_new_release__mutmut_42": x__post_new_release__mutmut_42,
    "x__post_new_release__mutmut_43": x__post_new_release__mutmut_43,
    "x__post_new_release__mutmut_44": x__post_new_release__mutmut_44,
    "x__post_new_release__mutmut_45": x__post_new_release__mutmut_45,
    "x__post_new_release__mutmut_46": x__post_new_release__mutmut_46,
    "x__post_new_release__mutmut_47": x__post_new_release__mutmut_47,
    "x__post_new_release__mutmut_48": x__post_new_release__mutmut_48,
    "x__post_new_release__mutmut_49": x__post_new_release__mutmut_49,
    "x__post_new_release__mutmut_50": x__post_new_release__mutmut_50,
    "x__post_new_release__mutmut_51": x__post_new_release__mutmut_51,
    "x__post_new_release__mutmut_52": x__post_new_release__mutmut_52,
    "x__post_new_release__mutmut_53": x__post_new_release__mutmut_53,
    "x__post_new_release__mutmut_54": x__post_new_release__mutmut_54,
    "x__post_new_release__mutmut_55": x__post_new_release__mutmut_55,
    "x__post_new_release__mutmut_56": x__post_new_release__mutmut_56,
    "x__post_new_release__mutmut_57": x__post_new_release__mutmut_57,
    "x__post_new_release__mutmut_58": x__post_new_release__mutmut_58,
    "x__post_new_release__mutmut_59": x__post_new_release__mutmut_59,
    "x__post_new_release__mutmut_60": x__post_new_release__mutmut_60,
    "x__post_new_release__mutmut_61": x__post_new_release__mutmut_61,
    "x__post_new_release__mutmut_62": x__post_new_release__mutmut_62,
    "x__post_new_release__mutmut_63": x__post_new_release__mutmut_63,
    "x__post_new_release__mutmut_64": x__post_new_release__mutmut_64,
    "x__post_new_release__mutmut_65": x__post_new_release__mutmut_65,
    "x__post_new_release__mutmut_66": x__post_new_release__mutmut_66,
    "x__post_new_release__mutmut_67": x__post_new_release__mutmut_67,
    "x__post_new_release__mutmut_68": x__post_new_release__mutmut_68,
    "x__post_new_release__mutmut_69": x__post_new_release__mutmut_69,
    "x__post_new_release__mutmut_70": x__post_new_release__mutmut_70,
    "x__post_new_release__mutmut_71": x__post_new_release__mutmut_71,
    "x__post_new_release__mutmut_72": x__post_new_release__mutmut_72,
    "x__post_new_release__mutmut_73": x__post_new_release__mutmut_73,
    "x__post_new_release__mutmut_74": x__post_new_release__mutmut_74,
    "x__post_new_release__mutmut_75": x__post_new_release__mutmut_75,
    "x__post_new_release__mutmut_76": x__post_new_release__mutmut_76,
    "x__post_new_release__mutmut_77": x__post_new_release__mutmut_77,
    "x__post_new_release__mutmut_78": x__post_new_release__mutmut_78,
    "x__post_new_release__mutmut_79": x__post_new_release__mutmut_79,
    "x__post_new_release__mutmut_80": x__post_new_release__mutmut_80,
    "x__post_new_release__mutmut_81": x__post_new_release__mutmut_81,
    "x__post_new_release__mutmut_82": x__post_new_release__mutmut_82,
    "x__post_new_release__mutmut_83": x__post_new_release__mutmut_83,
    "x__post_new_release__mutmut_84": x__post_new_release__mutmut_84,
    "x__post_new_release__mutmut_85": x__post_new_release__mutmut_85,
    "x__post_new_release__mutmut_86": x__post_new_release__mutmut_86,
    "x__post_new_release__mutmut_87": x__post_new_release__mutmut_87,
    "x__post_new_release__mutmut_88": x__post_new_release__mutmut_88,
    "x__post_new_release__mutmut_89": x__post_new_release__mutmut_89,
    "x__post_new_release__mutmut_90": x__post_new_release__mutmut_90,
    "x__post_new_release__mutmut_91": x__post_new_release__mutmut_91,
    "x__post_new_release__mutmut_92": x__post_new_release__mutmut_92,
    "x__post_new_release__mutmut_93": x__post_new_release__mutmut_93,
    "x__post_new_release__mutmut_94": x__post_new_release__mutmut_94,
    "x__post_new_release__mutmut_95": x__post_new_release__mutmut_95,
    "x__post_new_release__mutmut_96": x__post_new_release__mutmut_96,
    "x__post_new_release__mutmut_97": x__post_new_release__mutmut_97,
    "x__post_new_release__mutmut_98": x__post_new_release__mutmut_98,
    "x__post_new_release__mutmut_99": x__post_new_release__mutmut_99,
    "x__post_new_release__mutmut_100": x__post_new_release__mutmut_100,
    "x__post_new_release__mutmut_101": x__post_new_release__mutmut_101,
    "x__post_new_release__mutmut_102": x__post_new_release__mutmut_102,
    "x__post_new_release__mutmut_103": x__post_new_release__mutmut_103,
    "x__post_new_release__mutmut_104": x__post_new_release__mutmut_104,
    "x__post_new_release__mutmut_105": x__post_new_release__mutmut_105,
    "x__post_new_release__mutmut_106": x__post_new_release__mutmut_106,
    "x__post_new_release__mutmut_107": x__post_new_release__mutmut_107,
    "x__post_new_release__mutmut_108": x__post_new_release__mutmut_108,
}


def _post_new_release(*args, **kwargs):
    result = _mutmut_trampoline(
        x__post_new_release__mutmut_orig,
        x__post_new_release__mutmut_mutants,
        args,
        kwargs,
    )
    return result


_post_new_release.__signature__ = _mutmut_signature(x__post_new_release__mutmut_orig)
x__post_new_release__mutmut_orig.__name__ = "x__post_new_release"


async def x_sync_history__mutmut_orig(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_1(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = None
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_2(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info(None)

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_3(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("XXAuthenticating with Reddit...XX")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_4(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("authenticating with reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_5(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("AUTHENTICATING WITH REDDIT...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_6(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_7(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = None
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_8(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(None, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_9(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, None)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_10(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_11(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(
        github_manager,
    )
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_12(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_13(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(None)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_14(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(2)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_15(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        None,
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_16(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        None,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_17(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_18(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_19(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "XXLatest available bot release on GitHub is v%s.XX",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_20(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "latest available bot release on github is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_21(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "LATEST AVAILABLE BOT RELEASE ON GITHUB IS V%S.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_22(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on github is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_23(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = None

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_24(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(None)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_25(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_26(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            None,
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_27(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            None,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_28(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_29(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_30(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "XXNo posts found in r/%s. Posting latest available release.XX",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_31(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "no posts found in r/%s. posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_32(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "NO POSTS FOUND IN R/%S. POSTING LATEST AVAILABLE RELEASE.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_33(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_34(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = None
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_35(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            None,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_36(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            None,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_37(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            None,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_38(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            None,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_39(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            None,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_40(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_41(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_42(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_43(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_44(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_45(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(None, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_46(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, None, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_47(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, None)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_48(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_49(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_50(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(
            state_manager,
            new_submission.id,
        )
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_51(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = None
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_52(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[1]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_53(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = None
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_54(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(None)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_55(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info(None, latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_56(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", None)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_57(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info(latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_58(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info(
        "Latest post on Reddit is v%s.",
    )

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_59(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("XXLatest post on Reddit is v%s.XX", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_60(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("latest post on reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_61(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("LATEST POST ON REDDIT IS V%S.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_62(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_63(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version >= latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_64(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            None,
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_65(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            None,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_66(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            None,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_67(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_68(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_69(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_70(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "XXReddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.XX",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_71(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "reddit is out of sync (reddit: v%s, github: v%s). posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_72(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "REDDIT IS OUT OF SYNC (REDDIT: V%S, GITHUB: V%S). POSTING UPDATE.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_73(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (reddit: v%s, github: v%s). posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_74(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = None

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_75(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            None,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_76(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            None,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_77(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            None,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_78(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            None,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_79(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            None,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_80(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_81(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_82(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_83(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_84(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_85(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = None
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_86(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "XXtitleXX": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_87(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "TITLE": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_88(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "Title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_89(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "XXurlXX": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_90(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "URL": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_91(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "Url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_92(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "XXversionXX": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_93(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "VERSION": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_94(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "Version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_95(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "XXdirect_download_urlXX": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_96(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "DIRECT_DOWNLOAD_URL": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_97(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "Direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_98(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            None,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_99(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            None,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_100(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            None,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_101(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            None,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_102(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            None,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_103(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_104(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_105(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_106(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_107(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_108(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(None, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_109(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, None, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_110(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, None)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_111(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_112(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_113(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(
            state_manager,
            new_submission.id,
        )
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_114(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info(None)
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_115(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("XXReddit's latest post is up-to-date. Performing routine sync.XX")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_116(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("reddit's latest post is up-to-date. performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_117(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("REDDIT'S LATEST POST IS UP-TO-DATE. PERFORMING ROUTINE SYNC.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_118(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_119(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = None
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_120(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[2:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_121(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            None,
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_122(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            None,
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_123(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_124(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_125(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "XXChecking %s older post(s) to ensure they are marked as outdated.XX",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_126(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_127(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "CHECKING %S OLDER POST(S) TO ENSURE THEY ARE MARKED AS OUTDATED.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_128(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = None
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_129(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "XXtitleXX": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_130(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "TITLE": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_131(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "Title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_132(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "XXurlXX": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_133(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "URL": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_134(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "Url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_135(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "XXversionXX": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_136(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "VERSION": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_137(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "Version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_138(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "XXdirect_download_urlXX": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_139(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "DIRECT_DOWNLOAD_URL": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_140(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "Direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_141(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            None,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_142(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            None,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_143(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            None,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_144(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            None,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_145(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            None,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_146(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_147(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_148(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_149(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_150(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_151(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info(None)

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_152(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("XXNo older posts found to sync.XX")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_153(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("no older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_154(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("NO OLDER POSTS FOUND TO SYNC.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_155(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = None
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_156(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId == latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_157(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info(None)
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_158(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("XXState file is out of sync. Correcting it.XX")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_159(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("state file is out of sync. correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_160(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("STATE FILE IS OUT OF SYNC. CORRECTING IT.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_161(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_162(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(None, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_163(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, None, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_164(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, None)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_165(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_166(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_167(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(
                state_manager,
                latest_reddit_post.id,
            )
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_168(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info(None)
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_169(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("XXState file is already in sync.XX")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_170(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("state file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_171(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("STATE FILE IS ALREADY IN SYNC.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_172(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = None
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_173(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get(None, "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_174(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", None)
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_175(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_176(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get(
                "GITHUB_OUTPUT",
            )
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_177(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("XXGITHUB_OUTPUTXX", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_178(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("github_output", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_179(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("Github_output", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_180(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "XX/dev/nullXX")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_181(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/DEV/NULL")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_182(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open(None) as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_183(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(None).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_184(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("XXaXX") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_185(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("A") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_186(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("A") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_187(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write(None)
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_188(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("XXstate_changed=falseXX")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_189(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("STATE_CHANGED=FALSE")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_190(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("State_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_191(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info(None)
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_192(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("XXbot_state.json not found. Creating it now.XX")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_193(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_194(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("BOT_STATE.JSON NOT FOUND. CREATING IT NOW.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_195(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("Bot_state.json not found. creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, config)


async def x_sync_history__mutmut_196(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(None, latest_reddit_post.id, config)


async def x_sync_history__mutmut_197(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, None, config)


async def x_sync_history__mutmut_198(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, latest_reddit_post.id, None)


async def x_sync_history__mutmut_199(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(latest_reddit_post.id, config)


async def x_sync_history__mutmut_200(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(state_manager, config)


async def x_sync_history__mutmut_201(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    github_manager: GitHubManagerProtocol,
    reddit_manager: RedditManagerProtocol,
    template_manager: TemplateManagerProtocol,
) -> None:
    """Sync the Reddit post history with the latest GitHub release."""
    config = await config_manager.load_config()
    logger.info("Authenticating with Reddit...")

    latest_bot_release = await _get_latest_bot_release(github_manager, config)
    if not latest_bot_release:
        sys.exit(1)

    logger.info(
        "Latest available bot release on GitHub is v%s.",
        latest_bot_release.version,
    )
    bot_posts_on_sub = await _get_bot_posts_on_subreddit(reddit_manager)

    if not bot_posts_on_sub:
        logger.info(
            "No posts found in r/%s. Posting latest available release.",
            config.reddit.subreddit,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    latest_reddit_post = bot_posts_on_sub[0]
    latest_reddit_version = _parse_version_from_title(latest_reddit_post.title)
    logger.info("Latest post on Reddit is v%s.", latest_reddit_version)

    if latest_bot_release.version > latest_reddit_version:
        logger.info(
            "Reddit is out of sync (Reddit: v%s, GitHub: v%s). Posting update.",
            latest_reddit_version,
            latest_bot_release.version,
        )
        new_submission = await _post_new_release(
            reddit_manager,
            template_manager,
            latest_bot_release.version,
            latest_bot_release.url,
            config,
        )

        latest_release_details = {
            "title": new_submission.title,
            "url": new_submission.url,
            "version": latest_bot_release.version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            bot_posts_on_sub,
            latest_release_details,
            config,
        )
        await _update_bot_state(state_manager, new_submission.id, config)
        return

    logger.info("Reddit's latest post is up-to-date. Performing routine sync.")
    older_posts = bot_posts_on_sub[1:]
    if older_posts:
        logger.info(
            "Checking %s older post(s) to ensure they are marked as outdated.",
            len(older_posts),
        )
        latest_release_details = {
            "title": latest_reddit_post.title,
            "url": latest_reddit_post.url,
            "version": latest_reddit_version,
            "direct_download_url": latest_bot_release.url,
        }
        await _update_older_posts(
            reddit_manager,
            template_manager,
            older_posts,
            latest_release_details,
            config,
        )
    else:
        logger.info("No older posts found to sync.")

    try:
        state = await state_manager.load_state()
        if state.activePostId != latest_reddit_post.id:
            logger.info("State file is out of sync. Correcting it.")
            await _update_bot_state(state_manager, latest_reddit_post.id, config)
        else:
            logger.info("State file is already in sync.")
            github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
            with Path(github_output).open("a") as f:
                f.write("state_changed=false")
    except FileNotFoundError:
        logger.info("bot_state.json not found. Creating it now.")
        await _update_bot_state(
            state_manager,
            latest_reddit_post.id,
        )


x_sync_history__mutmut_mutants: ClassVar[MutantDict] = {
    "x_sync_history__mutmut_1": x_sync_history__mutmut_1,
    "x_sync_history__mutmut_2": x_sync_history__mutmut_2,
    "x_sync_history__mutmut_3": x_sync_history__mutmut_3,
    "x_sync_history__mutmut_4": x_sync_history__mutmut_4,
    "x_sync_history__mutmut_5": x_sync_history__mutmut_5,
    "x_sync_history__mutmut_6": x_sync_history__mutmut_6,
    "x_sync_history__mutmut_7": x_sync_history__mutmut_7,
    "x_sync_history__mutmut_8": x_sync_history__mutmut_8,
    "x_sync_history__mutmut_9": x_sync_history__mutmut_9,
    "x_sync_history__mutmut_10": x_sync_history__mutmut_10,
    "x_sync_history__mutmut_11": x_sync_history__mutmut_11,
    "x_sync_history__mutmut_12": x_sync_history__mutmut_12,
    "x_sync_history__mutmut_13": x_sync_history__mutmut_13,
    "x_sync_history__mutmut_14": x_sync_history__mutmut_14,
    "x_sync_history__mutmut_15": x_sync_history__mutmut_15,
    "x_sync_history__mutmut_16": x_sync_history__mutmut_16,
    "x_sync_history__mutmut_17": x_sync_history__mutmut_17,
    "x_sync_history__mutmut_18": x_sync_history__mutmut_18,
    "x_sync_history__mutmut_19": x_sync_history__mutmut_19,
    "x_sync_history__mutmut_20": x_sync_history__mutmut_20,
    "x_sync_history__mutmut_21": x_sync_history__mutmut_21,
    "x_sync_history__mutmut_22": x_sync_history__mutmut_22,
    "x_sync_history__mutmut_23": x_sync_history__mutmut_23,
    "x_sync_history__mutmut_24": x_sync_history__mutmut_24,
    "x_sync_history__mutmut_25": x_sync_history__mutmut_25,
    "x_sync_history__mutmut_26": x_sync_history__mutmut_26,
    "x_sync_history__mutmut_27": x_sync_history__mutmut_27,
    "x_sync_history__mutmut_28": x_sync_history__mutmut_28,
    "x_sync_history__mutmut_29": x_sync_history__mutmut_29,
    "x_sync_history__mutmut_30": x_sync_history__mutmut_30,
    "x_sync_history__mutmut_31": x_sync_history__mutmut_31,
    "x_sync_history__mutmut_32": x_sync_history__mutmut_32,
    "x_sync_history__mutmut_33": x_sync_history__mutmut_33,
    "x_sync_history__mutmut_34": x_sync_history__mutmut_34,
    "x_sync_history__mutmut_35": x_sync_history__mutmut_35,
    "x_sync_history__mutmut_36": x_sync_history__mutmut_36,
    "x_sync_history__mutmut_37": x_sync_history__mutmut_37,
    "x_sync_history__mutmut_38": x_sync_history__mutmut_38,
    "x_sync_history__mutmut_39": x_sync_history__mutmut_39,
    "x_sync_history__mutmut_40": x_sync_history__mutmut_40,
    "x_sync_history__mutmut_41": x_sync_history__mutmut_41,
    "x_sync_history__mutmut_42": x_sync_history__mutmut_42,
    "x_sync_history__mutmut_43": x_sync_history__mutmut_43,
    "x_sync_history__mutmut_44": x_sync_history__mutmut_44,
    "x_sync_history__mutmut_45": x_sync_history__mutmut_45,
    "x_sync_history__mutmut_46": x_sync_history__mutmut_46,
    "x_sync_history__mutmut_47": x_sync_history__mutmut_47,
    "x_sync_history__mutmut_48": x_sync_history__mutmut_48,
    "x_sync_history__mutmut_49": x_sync_history__mutmut_49,
    "x_sync_history__mutmut_50": x_sync_history__mutmut_50,
    "x_sync_history__mutmut_51": x_sync_history__mutmut_51,
    "x_sync_history__mutmut_52": x_sync_history__mutmut_52,
    "x_sync_history__mutmut_53": x_sync_history__mutmut_53,
    "x_sync_history__mutmut_54": x_sync_history__mutmut_54,
    "x_sync_history__mutmut_55": x_sync_history__mutmut_55,
    "x_sync_history__mutmut_56": x_sync_history__mutmut_56,
    "x_sync_history__mutmut_57": x_sync_history__mutmut_57,
    "x_sync_history__mutmut_58": x_sync_history__mutmut_58,
    "x_sync_history__mutmut_59": x_sync_history__mutmut_59,
    "x_sync_history__mutmut_60": x_sync_history__mutmut_60,
    "x_sync_history__mutmut_61": x_sync_history__mutmut_61,
    "x_sync_history__mutmut_62": x_sync_history__mutmut_62,
    "x_sync_history__mutmut_63": x_sync_history__mutmut_63,
    "x_sync_history__mutmut_64": x_sync_history__mutmut_64,
    "x_sync_history__mutmut_65": x_sync_history__mutmut_65,
    "x_sync_history__mutmut_66": x_sync_history__mutmut_66,
    "x_sync_history__mutmut_67": x_sync_history__mutmut_67,
    "x_sync_history__mutmut_68": x_sync_history__mutmut_68,
    "x_sync_history__mutmut_69": x_sync_history__mutmut_69,
    "x_sync_history__mutmut_70": x_sync_history__mutmut_70,
    "x_sync_history__mutmut_71": x_sync_history__mutmut_71,
    "x_sync_history__mutmut_72": x_sync_history__mutmut_72,
    "x_sync_history__mutmut_73": x_sync_history__mutmut_73,
    "x_sync_history__mutmut_74": x_sync_history__mutmut_74,
    "x_sync_history__mutmut_75": x_sync_history__mutmut_75,
    "x_sync_history__mutmut_76": x_sync_history__mutmut_76,
    "x_sync_history__mutmut_77": x_sync_history__mutmut_77,
    "x_sync_history__mutmut_78": x_sync_history__mutmut_78,
    "x_sync_history__mutmut_79": x_sync_history__mutmut_79,
    "x_sync_history__mutmut_80": x_sync_history__mutmut_80,
    "x_sync_history__mutmut_81": x_sync_history__mutmut_81,
    "x_sync_history__mutmut_82": x_sync_history__mutmut_82,
    "x_sync_history__mutmut_83": x_sync_history__mutmut_83,
    "x_sync_history__mutmut_84": x_sync_history__mutmut_84,
    "x_sync_history__mutmut_85": x_sync_history__mutmut_85,
    "x_sync_history__mutmut_86": x_sync_history__mutmut_86,
    "x_sync_history__mutmut_87": x_sync_history__mutmut_87,
    "x_sync_history__mutmut_88": x_sync_history__mutmut_88,
    "x_sync_history__mutmut_89": x_sync_history__mutmut_89,
    "x_sync_history__mutmut_90": x_sync_history__mutmut_90,
    "x_sync_history__mutmut_91": x_sync_history__mutmut_91,
    "x_sync_history__mutmut_92": x_sync_history__mutmut_92,
    "x_sync_history__mutmut_93": x_sync_history__mutmut_93,
    "x_sync_history__mutmut_94": x_sync_history__mutmut_94,
    "x_sync_history__mutmut_95": x_sync_history__mutmut_95,
    "x_sync_history__mutmut_96": x_sync_history__mutmut_96,
    "x_sync_history__mutmut_97": x_sync_history__mutmut_97,
    "x_sync_history__mutmut_98": x_sync_history__mutmut_98,
    "x_sync_history__mutmut_99": x_sync_history__mutmut_99,
    "x_sync_history__mutmut_100": x_sync_history__mutmut_100,
    "x_sync_history__mutmut_101": x_sync_history__mutmut_101,
    "x_sync_history__mutmut_102": x_sync_history__mutmut_102,
    "x_sync_history__mutmut_103": x_sync_history__mutmut_103,
    "x_sync_history__mutmut_104": x_sync_history__mutmut_104,
    "x_sync_history__mutmut_105": x_sync_history__mutmut_105,
    "x_sync_history__mutmut_106": x_sync_history__mutmut_106,
    "x_sync_history__mutmut_107": x_sync_history__mutmut_107,
    "x_sync_history__mutmut_108": x_sync_history__mutmut_108,
    "x_sync_history__mutmut_109": x_sync_history__mutmut_109,
    "x_sync_history__mutmut_110": x_sync_history__mutmut_110,
    "x_sync_history__mutmut_111": x_sync_history__mutmut_111,
    "x_sync_history__mutmut_112": x_sync_history__mutmut_112,
    "x_sync_history__mutmut_113": x_sync_history__mutmut_113,
    "x_sync_history__mutmut_114": x_sync_history__mutmut_114,
    "x_sync_history__mutmut_115": x_sync_history__mutmut_115,
    "x_sync_history__mutmut_116": x_sync_history__mutmut_116,
    "x_sync_history__mutmut_117": x_sync_history__mutmut_117,
    "x_sync_history__mutmut_118": x_sync_history__mutmut_118,
    "x_sync_history__mutmut_119": x_sync_history__mutmut_119,
    "x_sync_history__mutmut_120": x_sync_history__mutmut_120,
    "x_sync_history__mutmut_121": x_sync_history__mutmut_121,
    "x_sync_history__mutmut_122": x_sync_history__mutmut_122,
    "x_sync_history__mutmut_123": x_sync_history__mutmut_123,
    "x_sync_history__mutmut_124": x_sync_history__mutmut_124,
    "x_sync_history__mutmut_125": x_sync_history__mutmut_125,
    "x_sync_history__mutmut_126": x_sync_history__mutmut_126,
    "x_sync_history__mutmut_127": x_sync_history__mutmut_127,
    "x_sync_history__mutmut_128": x_sync_history__mutmut_128,
    "x_sync_history__mutmut_129": x_sync_history__mutmut_129,
    "x_sync_history__mutmut_130": x_sync_history__mutmut_130,
    "x_sync_history__mutmut_131": x_sync_history__mutmut_131,
    "x_sync_history__mutmut_132": x_sync_history__mutmut_132,
    "x_sync_history__mutmut_133": x_sync_history__mutmut_133,
    "x_sync_history__mutmut_134": x_sync_history__mutmut_134,
    "x_sync_history__mutmut_135": x_sync_history__mutmut_135,
    "x_sync_history__mutmut_136": x_sync_history__mutmut_136,
    "x_sync_history__mutmut_137": x_sync_history__mutmut_137,
    "x_sync_history__mutmut_138": x_sync_history__mutmut_138,
    "x_sync_history__mutmut_139": x_sync_history__mutmut_139,
    "x_sync_history__mutmut_140": x_sync_history__mutmut_140,
    "x_sync_history__mutmut_141": x_sync_history__mutmut_141,
    "x_sync_history__mutmut_142": x_sync_history__mutmut_142,
    "x_sync_history__mutmut_143": x_sync_history__mutmut_143,
    "x_sync_history__mutmut_144": x_sync_history__mutmut_144,
    "x_sync_history__mutmut_145": x_sync_history__mutmut_145,
    "x_sync_history__mutmut_146": x_sync_history__mutmut_146,
    "x_sync_history__mutmut_147": x_sync_history__mutmut_147,
    "x_sync_history__mutmut_148": x_sync_history__mutmut_148,
    "x_sync_history__mutmut_149": x_sync_history__mutmut_149,
    "x_sync_history__mutmut_150": x_sync_history__mutmut_150,
    "x_sync_history__mutmut_151": x_sync_history__mutmut_151,
    "x_sync_history__mutmut_152": x_sync_history__mutmut_152,
    "x_sync_history__mutmut_153": x_sync_history__mutmut_153,
    "x_sync_history__mutmut_154": x_sync_history__mutmut_154,
    "x_sync_history__mutmut_155": x_sync_history__mutmut_155,
    "x_sync_history__mutmut_156": x_sync_history__mutmut_156,
    "x_sync_history__mutmut_157": x_sync_history__mutmut_157,
    "x_sync_history__mutmut_158": x_sync_history__mutmut_158,
    "x_sync_history__mutmut_159": x_sync_history__mutmut_159,
    "x_sync_history__mutmut_160": x_sync_history__mutmut_160,
    "x_sync_history__mutmut_161": x_sync_history__mutmut_161,
    "x_sync_history__mutmut_162": x_sync_history__mutmut_162,
    "x_sync_history__mutmut_163": x_sync_history__mutmut_163,
    "x_sync_history__mutmut_164": x_sync_history__mutmut_164,
    "x_sync_history__mutmut_165": x_sync_history__mutmut_165,
    "x_sync_history__mutmut_166": x_sync_history__mutmut_166,
    "x_sync_history__mutmut_167": x_sync_history__mutmut_167,
    "x_sync_history__mutmut_168": x_sync_history__mutmut_168,
    "x_sync_history__mutmut_169": x_sync_history__mutmut_169,
    "x_sync_history__mutmut_170": x_sync_history__mutmut_170,
    "x_sync_history__mutmut_171": x_sync_history__mutmut_171,
    "x_sync_history__mutmut_172": x_sync_history__mutmut_172,
    "x_sync_history__mutmut_173": x_sync_history__mutmut_173,
    "x_sync_history__mutmut_174": x_sync_history__mutmut_174,
    "x_sync_history__mutmut_175": x_sync_history__mutmut_175,
    "x_sync_history__mutmut_176": x_sync_history__mutmut_176,
    "x_sync_history__mutmut_177": x_sync_history__mutmut_177,
    "x_sync_history__mutmut_178": x_sync_history__mutmut_178,
    "x_sync_history__mutmut_179": x_sync_history__mutmut_179,
    "x_sync_history__mutmut_180": x_sync_history__mutmut_180,
    "x_sync_history__mutmut_181": x_sync_history__mutmut_181,
    "x_sync_history__mutmut_182": x_sync_history__mutmut_182,
    "x_sync_history__mutmut_183": x_sync_history__mutmut_183,
    "x_sync_history__mutmut_184": x_sync_history__mutmut_184,
    "x_sync_history__mutmut_185": x_sync_history__mutmut_185,
    "x_sync_history__mutmut_186": x_sync_history__mutmut_186,
    "x_sync_history__mutmut_187": x_sync_history__mutmut_187,
    "x_sync_history__mutmut_188": x_sync_history__mutmut_188,
    "x_sync_history__mutmut_189": x_sync_history__mutmut_189,
    "x_sync_history__mutmut_190": x_sync_history__mutmut_190,
    "x_sync_history__mutmut_191": x_sync_history__mutmut_191,
    "x_sync_history__mutmut_192": x_sync_history__mutmut_192,
    "x_sync_history__mutmut_193": x_sync_history__mutmut_193,
    "x_sync_history__mutmut_194": x_sync_history__mutmut_194,
    "x_sync_history__mutmut_195": x_sync_history__mutmut_195,
    "x_sync_history__mutmut_196": x_sync_history__mutmut_196,
    "x_sync_history__mutmut_197": x_sync_history__mutmut_197,
    "x_sync_history__mutmut_198": x_sync_history__mutmut_198,
    "x_sync_history__mutmut_199": x_sync_history__mutmut_199,
    "x_sync_history__mutmut_200": x_sync_history__mutmut_200,
    "x_sync_history__mutmut_201": x_sync_history__mutmut_201,
}


def sync_history(*args, **kwargs):
    result = _mutmut_trampoline(
        x_sync_history__mutmut_orig, x_sync_history__mutmut_mutants, args, kwargs
    )
    return result


sync_history.__signature__ = _mutmut_signature(x_sync_history__mutmut_orig)
x_sync_history__mutmut_orig.__name__ = "x_sync_history"
