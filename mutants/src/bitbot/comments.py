"""This module checks for comments on the active Reddit post."""

import os
import re
from datetime import datetime, timedelta, timezone
from pathlib import Path

from .interfaces.config_protocol import ConfigManagerProtocol
from .interfaces.reddit_protocol import RedditManagerProtocol
from .interfaces.state_protocol import StateManagerProtocol
from .logging import get_logger

logger = get_logger(__name__)
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg=None):
    """Forward call to original or mutated function, depending on the environment"""
    import os

    mutant_under_test = os.environ["MUTANT_UNDER_TEST"]
    if mutant_under_test == "fail":
        from mutmut.__main__ import MutmutProgrammaticFailException

        raise MutmutProgrammaticFailException("Failed programmatically")
    elif mutant_under_test == "stats":
        from mutmut.__main__ import record_trampoline_hit

        record_trampoline_hit(orig.__module__ + "." + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + "." + orig.__name__ + "__mutmut_"
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition(".")[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result


from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_yield_from_trampoline(orig, mutants, call_args, call_kwargs, self_arg=None):
    """Forward call to original or mutated function, depending on the environment"""
    import os

    mutant_under_test = os.environ["MUTANT_UNDER_TEST"]
    if mutant_under_test == "fail":
        from mutmut.__main__ import MutmutProgrammaticFailException

        raise MutmutProgrammaticFailException("Failed programmatically")
    elif mutant_under_test == "stats":
        from mutmut.__main__ import record_trampoline_hit

        record_trampoline_hit(orig.__module__ + "." + orig.__name__)
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + "." + orig.__name__ + "__mutmut_"
    if not mutant_under_test.startswith(prefix):
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition(".")[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = yield from mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = yield from mutants[mutant_name](*call_args, **call_kwargs)
    return result


async def x_check_comments__mutmut_orig(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_1(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = None
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_2(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = None
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_3(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = None

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_4(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = True

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_5(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_6(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info(None)
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_7(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("XXNo active post ID in state file. Exiting pulse.XX")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_8(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("no active post id in state file. exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_9(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("NO ACTIVE POST ID IN STATE FILE. EXITING PULSE.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_10(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post id in state file. exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_11(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return True

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_12(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_13(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info(None)
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_14(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("XXNo lastCheckTimestamp in state file. Exiting pulse.XX")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_15(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("no lastchecktimestamp in state file. exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_16(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("NO LASTCHECKTIMESTAMP IN STATE FILE. EXITING PULSE.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_17(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastchecktimestamp in state file. exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_18(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return True

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_19(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = None
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_20(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(None)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_21(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = None

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_22(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(None)

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_23(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(
        state.lastCheckTimestamp.replace(None, "+00:00")
    )

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_24(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", None))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_25(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_26(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(
        state.lastCheckTimestamp.replace(
            "Z",
        )
    )

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_27(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(
        state.lastCheckTimestamp.replace("XXZXX", "+00:00")
    )

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_28(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_29(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(
        state.lastCheckTimestamp.replace("Z", "XX+00:00XX")
    )

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_30(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now <= (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_31(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check - timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_32(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=None)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_33(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            None,
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_34(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            None,
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_35(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_36(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_37(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "XXNot time yet. Next check in %s.XX",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_38(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "not time yet. next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_39(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "NOT TIME YET. NEXT CHECK IN %S.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_40(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_41(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(None),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_42(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check - timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_43(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(((last_check + timedelta(seconds=None)) - now).total_seconds()),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_44(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) + now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_45(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = None
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_46(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get(None, "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_47(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", None)
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_48(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_49(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get(
            "GITHUB_OUTPUT",
        )
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_50(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("XXGITHUB_OUTPUTXX", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_51(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("github_output", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_52(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("Github_output", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_53(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "XX/dev/nullXX")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_54(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/DEV/NULL")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_55(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open(None) as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_56(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(None).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_57(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("XXaXX") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_58(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("A") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_59(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("A") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_60(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(None)
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_61(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("XXstate_changed=falseXX")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_62(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("STATE_CHANGED=FALSE")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_63(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("State_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_64(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return True

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_65(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info(None, state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_66(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", None)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_67(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info(state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_68(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info(
        "Time for a real check on post: %s",
    )
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_69(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("XXTime for a real check on post: %sXX", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_70(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_71(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("TIME FOR A REAL CHECK ON POST: %S", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_72(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = None
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_73(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(None)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_74(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_75(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning(None, state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_76(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", None)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_77(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning(state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_78(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning(
                "Could not find submission with ID: %s",
            )
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_79(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning(
                "XXCould not find submission with ID: %sXX", state.activePostId
            )
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_80(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("could not find submission with id: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_81(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("COULD NOT FIND SUBMISSION WITH ID: %S", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_82(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with id: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_83(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return True

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_84(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = None

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_85(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(None)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_86(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = None
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_87(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile(None, re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_88(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), None)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_89(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile(re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_90(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile(
            "|".join(config.feedback.workingKeywords),
        )
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_91(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(None), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_92(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("XX|XX".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_93(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = None
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_94(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile(None, re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_95(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), None)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_96(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile(re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_97(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile(
            "|".join(config.feedback.notWorkingKeywords),
        )
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_98(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(None), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_99(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile(
            "XX|XX".join(config.feedback.notWorkingKeywords), re.I
        )
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_100(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = None
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_101(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(None)
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_102(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(2 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_103(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(None))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_104(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = None
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_105(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(None)
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_106(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(2 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_107(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(None))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_108(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = None
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_109(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score + negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_110(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            None,
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_111(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            None,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_112(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            None,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_113(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            None,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_114(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_115(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_116(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_117(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_118(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "XXComment analysis: Positive=%s, Negative=%s, Net Score=%sXX",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_119(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "comment analysis: positive=%s, negative=%s, net score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_120(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "COMMENT ANALYSIS: POSITIVE=%S, NEGATIVE=%S, NET SCORE=%S",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_121(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: positive=%s, negative=%s, net score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_122(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = None
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_123(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score < -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_124(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= +threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_125(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = None
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_126(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score > threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_127(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = None
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_128(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = None

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_129(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = None

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_130(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            None, new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_131(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace("{{status}}", None)

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_132(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(new_status_text)

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_133(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}",
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_134(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "XX{{status}}XX", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_135(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{STATUS}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_136(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = None
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_137(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(None, re.MULTILINE | re.DOTALL)
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_138(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(config.feedback.statusLineRegex, None)
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_139(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(re.MULTILINE | re.DOTALL)
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_140(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex,
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_141(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE & re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_142(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_143(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(None):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_144(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(None)
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_145(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "XXCould not find status line in post. XX"
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_146(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_147(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "COULD NOT FIND STATUS LINE IN POST. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_148(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "XXIt may have been edited or is an outdated post.XX"
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_149(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "it may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_150(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "IT MAY HAVE BEEN EDITED OR IS AN OUTDATED POST."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_151(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line == submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_152(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = None
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_153(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(None, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_154(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, None)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_155(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_156(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(
                new_status_line,
            )
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_157(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(None, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_158(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, None)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_159(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_160(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(
                submission.id,
            )
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_161(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info(None, new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_162(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", None)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_163(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info(new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_164(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info(
                "Status updated to: %s",
            )
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_165(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("XXStatus updated to: %sXX", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_166(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_167(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("STATUS UPDATED TO: %S", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_168(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info(None)

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_169(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("XXStatus is already correct.XX")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_170(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_171(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("STATUS IS ALREADY CORRECT.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_172(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) >= state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_173(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = None
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_174(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = None
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_175(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = False
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_176(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds <= config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_177(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = None
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_178(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    None,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_179(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    None,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_180(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_181(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_182(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds - config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_183(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = None

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_184(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = False

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_185(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount == len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_186(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = None
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_187(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = None

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_188(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = False

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_189(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error(None, e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_190(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", None, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_191(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=None)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_192(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error(e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_193(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_194(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error(
            "An exception occurred during check: %s",
            e,
        )
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_195(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("XXAn exception occurred during check: %sXX", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_196(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("an exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_197(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("AN EXCEPTION OCCURRED DURING CHECK: %S", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_198(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=False)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_199(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = None
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_200(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace(None, "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_201(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", None)
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_202(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_203(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace(
            "+00:00",
        )
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_204(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("XX+00:00XX", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_205(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "XXZXX")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_206(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_207(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info(None)
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_208(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("XXMeaningful state change detected. Saving state file.XX")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_209(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("meaningful state change detected. saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_210(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("MEANINGFUL STATE CHANGE DETECTED. SAVING STATE FILE.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_211(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_212(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(None)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_213(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info(None)

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_214(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("XXNo meaningful state change detected. Skipping file write.XX")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_215(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("no meaningful state change detected. skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_216(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("NO MEANINGFUL STATE CHANGE DETECTED. SKIPPING FILE WRITE.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_217(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_218(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = None
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_219(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get(None, "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_220(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", None)
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_221(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_222(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get(
            "GITHUB_OUTPUT",
        )
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_223(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("XXGITHUB_OUTPUTXX", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_224(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("github_output", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_225(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("Github_output", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_226(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "XX/dev/nullXX")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_227(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/DEV/NULL")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_228(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open(None) as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_229(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(None).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_230(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("XXaXX") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_231(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("A") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_232(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("A") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_233(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(None)
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_234(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).upper()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_235(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(None).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_236(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            None,
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_237(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            None,
        )
    return True


async def x_check_comments__mutmut_238(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_239(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
        )
    return True


async def x_check_comments__mutmut_240(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "XXPulse check complete. Next interval: %ssXX",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_241(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "pulse check complete. next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_242(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "PULSE CHECK COMPLETE. NEXT INTERVAL: %SS",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_243(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. next interval: %ss",
            state.currentIntervalSeconds,
        )
    return True


async def x_check_comments__mutmut_244(
    config_manager: ConfigManagerProtocol,
    state_manager: StateManagerProtocol,
    reddit_manager: RedditManagerProtocol,
) -> bool:
    """Check for comments on the active Reddit post.

    This function analyzes feedback, and updates the post status with an
    adaptive timer.

    Returns:
        True if a check was performed, False otherwise.
    """
    config = await config_manager.load_config()
    state = await state_manager.load_state()
    state_was_meaningfully_updated = False

    if not state.activePostId:
        logger.info("No active post ID in state file. Exiting pulse.")
        return False

    if not state.lastCheckTimestamp:
        logger.info("No lastCheckTimestamp in state file. Exiting pulse.")
        return False

    now = datetime.now(timezone.utc)
    last_check = datetime.fromisoformat(state.lastCheckTimestamp.replace("Z", "+00:00"))

    if now < (last_check + timedelta(seconds=state.currentIntervalSeconds)):
        logger.info(
            "Not time yet. Next check in %s.",
            int(
                (
                    (last_check + timedelta(seconds=state.currentIntervalSeconds)) - now
                ).total_seconds()
            ),
        )
        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write("state_changed=false")
        return False

    logger.info("Time for a real check on post: %s", state.activePostId)
    try:
        submission = await reddit_manager.get_post_by_id(state.activePostId)
        if not submission:
            logger.warning("Could not find submission with ID: %s", state.activePostId)
            return False

        comments = await reddit_manager.get_comments(submission)

        working_kw = re.compile("|".join(config.feedback.workingKeywords), re.I)
        not_working_kw = re.compile("|".join(config.feedback.notWorkingKeywords), re.I)
        positive_score = sum(1 for c in comments if working_kw.search(c.body))
        negative_score = sum(1 for c in comments if not_working_kw.search(c.body))
        net_score = positive_score - negative_score
        logger.info(
            "Comment analysis: Positive=%s, Negative=%s, Net Score=%s",
            positive_score,
            negative_score,
            net_score,
        )

        threshold = config.feedback.minFeedbackCount
        if net_score <= -threshold:
            new_status_text = config.feedback.labels.broken
        elif net_score >= threshold:
            new_status_text = config.feedback.labels.working
        else:
            new_status_text = config.feedback.labels.unknown

        new_status_line = config.feedback.statusLineFormat.replace(
            "{{status}}", new_status_text
        )

        status_regex = re.compile(
            config.feedback.statusLineRegex, re.MULTILINE | re.DOTALL
        )
        if not status_regex.search(submission.body):
            logger.warning(
                "Could not find status line in post. "
                "It may have been edited or is an outdated post."
            )
        elif new_status_line != submission.body:
            updated_body = status_regex.sub(new_status_line, submission.body)
            await reddit_manager.update_post_body(submission.id, updated_body)
            logger.info("Status updated to: %s", new_status_text)
        else:
            logger.info("Status is already correct.")

        if len(comments) > state.lastCommentCount:
            state.currentIntervalSeconds = config.timing.firstCheck
            state_was_meaningfully_updated = True
        else:
            if state.currentIntervalSeconds < config.timing.maxWait:
                state.currentIntervalSeconds = min(
                    config.timing.maxWait,
                    state.currentIntervalSeconds + config.timing.increaseBy,
                )
                state_was_meaningfully_updated = True

        if state.lastCommentCount != len(comments):
            state.lastCommentCount = len(comments)
            state_was_meaningfully_updated = True

    except Exception as e:
        logger.error("An exception occurred during check: %s", e, exc_info=True)
    finally:
        state.lastCheckTimestamp = now.isoformat().replace("+00:00", "Z")
        if state_was_meaningfully_updated:
            logger.info("Meaningful state change detected. Saving state file.")
            await state_manager.save_state(state)
        else:
            logger.info("No meaningful state change detected. Skipping file write.")

        github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")
        with Path(github_output).open("a") as f:
            f.write(f"state_changed={str(state_was_meaningfully_updated).lower()}")
        logger.info(
            "Pulse check complete. Next interval: %ss",
            state.currentIntervalSeconds,
        )
    return False


x_check_comments__mutmut_mutants: ClassVar[MutantDict] = {
    "x_check_comments__mutmut_1": x_check_comments__mutmut_1,
    "x_check_comments__mutmut_2": x_check_comments__mutmut_2,
    "x_check_comments__mutmut_3": x_check_comments__mutmut_3,
    "x_check_comments__mutmut_4": x_check_comments__mutmut_4,
    "x_check_comments__mutmut_5": x_check_comments__mutmut_5,
    "x_check_comments__mutmut_6": x_check_comments__mutmut_6,
    "x_check_comments__mutmut_7": x_check_comments__mutmut_7,
    "x_check_comments__mutmut_8": x_check_comments__mutmut_8,
    "x_check_comments__mutmut_9": x_check_comments__mutmut_9,
    "x_check_comments__mutmut_10": x_check_comments__mutmut_10,
    "x_check_comments__mutmut_11": x_check_comments__mutmut_11,
    "x_check_comments__mutmut_12": x_check_comments__mutmut_12,
    "x_check_comments__mutmut_13": x_check_comments__mutmut_13,
    "x_check_comments__mutmut_14": x_check_comments__mutmut_14,
    "x_check_comments__mutmut_15": x_check_comments__mutmut_15,
    "x_check_comments__mutmut_16": x_check_comments__mutmut_16,
    "x_check_comments__mutmut_17": x_check_comments__mutmut_17,
    "x_check_comments__mutmut_18": x_check_comments__mutmut_18,
    "x_check_comments__mutmut_19": x_check_comments__mutmut_19,
    "x_check_comments__mutmut_20": x_check_comments__mutmut_20,
    "x_check_comments__mutmut_21": x_check_comments__mutmut_21,
    "x_check_comments__mutmut_22": x_check_comments__mutmut_22,
    "x_check_comments__mutmut_23": x_check_comments__mutmut_23,
    "x_check_comments__mutmut_24": x_check_comments__mutmut_24,
    "x_check_comments__mutmut_25": x_check_comments__mutmut_25,
    "x_check_comments__mutmut_26": x_check_comments__mutmut_26,
    "x_check_comments__mutmut_27": x_check_comments__mutmut_27,
    "x_check_comments__mutmut_28": x_check_comments__mutmut_28,
    "x_check_comments__mutmut_29": x_check_comments__mutmut_29,
    "x_check_comments__mutmut_30": x_check_comments__mutmut_30,
    "x_check_comments__mutmut_31": x_check_comments__mutmut_31,
    "x_check_comments__mutmut_32": x_check_comments__mutmut_32,
    "x_check_comments__mutmut_33": x_check_comments__mutmut_33,
    "x_check_comments__mutmut_34": x_check_comments__mutmut_34,
    "x_check_comments__mutmut_35": x_check_comments__mutmut_35,
    "x_check_comments__mutmut_36": x_check_comments__mutmut_36,
    "x_check_comments__mutmut_37": x_check_comments__mutmut_37,
    "x_check_comments__mutmut_38": x_check_comments__mutmut_38,
    "x_check_comments__mutmut_39": x_check_comments__mutmut_39,
    "x_check_comments__mutmut_40": x_check_comments__mutmut_40,
    "x_check_comments__mutmut_41": x_check_comments__mutmut_41,
    "x_check_comments__mutmut_42": x_check_comments__mutmut_42,
    "x_check_comments__mutmut_43": x_check_comments__mutmut_43,
    "x_check_comments__mutmut_44": x_check_comments__mutmut_44,
    "x_check_comments__mutmut_45": x_check_comments__mutmut_45,
    "x_check_comments__mutmut_46": x_check_comments__mutmut_46,
    "x_check_comments__mutmut_47": x_check_comments__mutmut_47,
    "x_check_comments__mutmut_48": x_check_comments__mutmut_48,
    "x_check_comments__mutmut_49": x_check_comments__mutmut_49,
    "x_check_comments__mutmut_50": x_check_comments__mutmut_50,
    "x_check_comments__mutmut_51": x_check_comments__mutmut_51,
    "x_check_comments__mutmut_52": x_check_comments__mutmut_52,
    "x_check_comments__mutmut_53": x_check_comments__mutmut_53,
    "x_check_comments__mutmut_54": x_check_comments__mutmut_54,
    "x_check_comments__mutmut_55": x_check_comments__mutmut_55,
    "x_check_comments__mutmut_56": x_check_comments__mutmut_56,
    "x_check_comments__mutmut_57": x_check_comments__mutmut_57,
    "x_check_comments__mutmut_58": x_check_comments__mutmut_58,
    "x_check_comments__mutmut_59": x_check_comments__mutmut_59,
    "x_check_comments__mutmut_60": x_check_comments__mutmut_60,
    "x_check_comments__mutmut_61": x_check_comments__mutmut_61,
    "x_check_comments__mutmut_62": x_check_comments__mutmut_62,
    "x_check_comments__mutmut_63": x_check_comments__mutmut_63,
    "x_check_comments__mutmut_64": x_check_comments__mutmut_64,
    "x_check_comments__mutmut_65": x_check_comments__mutmut_65,
    "x_check_comments__mutmut_66": x_check_comments__mutmut_66,
    "x_check_comments__mutmut_67": x_check_comments__mutmut_67,
    "x_check_comments__mutmut_68": x_check_comments__mutmut_68,
    "x_check_comments__mutmut_69": x_check_comments__mutmut_69,
    "x_check_comments__mutmut_70": x_check_comments__mutmut_70,
    "x_check_comments__mutmut_71": x_check_comments__mutmut_71,
    "x_check_comments__mutmut_72": x_check_comments__mutmut_72,
    "x_check_comments__mutmut_73": x_check_comments__mutmut_73,
    "x_check_comments__mutmut_74": x_check_comments__mutmut_74,
    "x_check_comments__mutmut_75": x_check_comments__mutmut_75,
    "x_check_comments__mutmut_76": x_check_comments__mutmut_76,
    "x_check_comments__mutmut_77": x_check_comments__mutmut_77,
    "x_check_comments__mutmut_78": x_check_comments__mutmut_78,
    "x_check_comments__mutmut_79": x_check_comments__mutmut_79,
    "x_check_comments__mutmut_80": x_check_comments__mutmut_80,
    "x_check_comments__mutmut_81": x_check_comments__mutmut_81,
    "x_check_comments__mutmut_82": x_check_comments__mutmut_82,
    "x_check_comments__mutmut_83": x_check_comments__mutmut_83,
    "x_check_comments__mutmut_84": x_check_comments__mutmut_84,
    "x_check_comments__mutmut_85": x_check_comments__mutmut_85,
    "x_check_comments__mutmut_86": x_check_comments__mutmut_86,
    "x_check_comments__mutmut_87": x_check_comments__mutmut_87,
    "x_check_comments__mutmut_88": x_check_comments__mutmut_88,
    "x_check_comments__mutmut_89": x_check_comments__mutmut_89,
    "x_check_comments__mutmut_90": x_check_comments__mutmut_90,
    "x_check_comments__mutmut_91": x_check_comments__mutmut_91,
    "x_check_comments__mutmut_92": x_check_comments__mutmut_92,
    "x_check_comments__mutmut_93": x_check_comments__mutmut_93,
    "x_check_comments__mutmut_94": x_check_comments__mutmut_94,
    "x_check_comments__mutmut_95": x_check_comments__mutmut_95,
    "x_check_comments__mutmut_96": x_check_comments__mutmut_96,
    "x_check_comments__mutmut_97": x_check_comments__mutmut_97,
    "x_check_comments__mutmut_98": x_check_comments__mutmut_98,
    "x_check_comments__mutmut_99": x_check_comments__mutmut_99,
    "x_check_comments__mutmut_100": x_check_comments__mutmut_100,
    "x_check_comments__mutmut_101": x_check_comments__mutmut_101,
    "x_check_comments__mutmut_102": x_check_comments__mutmut_102,
    "x_check_comments__mutmut_103": x_check_comments__mutmut_103,
    "x_check_comments__mutmut_104": x_check_comments__mutmut_104,
    "x_check_comments__mutmut_105": x_check_comments__mutmut_105,
    "x_check_comments__mutmut_106": x_check_comments__mutmut_106,
    "x_check_comments__mutmut_107": x_check_comments__mutmut_107,
    "x_check_comments__mutmut_108": x_check_comments__mutmut_108,
    "x_check_comments__mutmut_109": x_check_comments__mutmut_109,
    "x_check_comments__mutmut_110": x_check_comments__mutmut_110,
    "x_check_comments__mutmut_111": x_check_comments__mutmut_111,
    "x_check_comments__mutmut_112": x_check_comments__mutmut_112,
    "x_check_comments__mutmut_113": x_check_comments__mutmut_113,
    "x_check_comments__mutmut_114": x_check_comments__mutmut_114,
    "x_check_comments__mutmut_115": x_check_comments__mutmut_115,
    "x_check_comments__mutmut_116": x_check_comments__mutmut_116,
    "x_check_comments__mutmut_117": x_check_comments__mutmut_117,
    "x_check_comments__mutmut_118": x_check_comments__mutmut_118,
    "x_check_comments__mutmut_119": x_check_comments__mutmut_119,
    "x_check_comments__mutmut_120": x_check_comments__mutmut_120,
    "x_check_comments__mutmut_121": x_check_comments__mutmut_121,
    "x_check_comments__mutmut_122": x_check_comments__mutmut_122,
    "x_check_comments__mutmut_123": x_check_comments__mutmut_123,
    "x_check_comments__mutmut_124": x_check_comments__mutmut_124,
    "x_check_comments__mutmut_125": x_check_comments__mutmut_125,
    "x_check_comments__mutmut_126": x_check_comments__mutmut_126,
    "x_check_comments__mutmut_127": x_check_comments__mutmut_127,
    "x_check_comments__mutmut_128": x_check_comments__mutmut_128,
    "x_check_comments__mutmut_129": x_check_comments__mutmut_129,
    "x_check_comments__mutmut_130": x_check_comments__mutmut_130,
    "x_check_comments__mutmut_131": x_check_comments__mutmut_131,
    "x_check_comments__mutmut_132": x_check_comments__mutmut_132,
    "x_check_comments__mutmut_133": x_check_comments__mutmut_133,
    "x_check_comments__mutmut_134": x_check_comments__mutmut_134,
    "x_check_comments__mutmut_135": x_check_comments__mutmut_135,
    "x_check_comments__mutmut_136": x_check_comments__mutmut_136,
    "x_check_comments__mutmut_137": x_check_comments__mutmut_137,
    "x_check_comments__mutmut_138": x_check_comments__mutmut_138,
    "x_check_comments__mutmut_139": x_check_comments__mutmut_139,
    "x_check_comments__mutmut_140": x_check_comments__mutmut_140,
    "x_check_comments__mutmut_141": x_check_comments__mutmut_141,
    "x_check_comments__mutmut_142": x_check_comments__mutmut_142,
    "x_check_comments__mutmut_143": x_check_comments__mutmut_143,
    "x_check_comments__mutmut_144": x_check_comments__mutmut_144,
    "x_check_comments__mutmut_145": x_check_comments__mutmut_145,
    "x_check_comments__mutmut_146": x_check_comments__mutmut_146,
    "x_check_comments__mutmut_147": x_check_comments__mutmut_147,
    "x_check_comments__mutmut_148": x_check_comments__mutmut_148,
    "x_check_comments__mutmut_149": x_check_comments__mutmut_149,
    "x_check_comments__mutmut_150": x_check_comments__mutmut_150,
    "x_check_comments__mutmut_151": x_check_comments__mutmut_151,
    "x_check_comments__mutmut_152": x_check_comments__mutmut_152,
    "x_check_comments__mutmut_153": x_check_comments__mutmut_153,
    "x_check_comments__mutmut_154": x_check_comments__mutmut_154,
    "x_check_comments__mutmut_155": x_check_comments__mutmut_155,
    "x_check_comments__mutmut_156": x_check_comments__mutmut_156,
    "x_check_comments__mutmut_157": x_check_comments__mutmut_157,
    "x_check_comments__mutmut_158": x_check_comments__mutmut_158,
    "x_check_comments__mutmut_159": x_check_comments__mutmut_159,
    "x_check_comments__mutmut_160": x_check_comments__mutmut_160,
    "x_check_comments__mutmut_161": x_check_comments__mutmut_161,
    "x_check_comments__mutmut_162": x_check_comments__mutmut_162,
    "x_check_comments__mutmut_163": x_check_comments__mutmut_163,
    "x_check_comments__mutmut_164": x_check_comments__mutmut_164,
    "x_check_comments__mutmut_165": x_check_comments__mutmut_165,
    "x_check_comments__mutmut_166": x_check_comments__mutmut_166,
    "x_check_comments__mutmut_167": x_check_comments__mutmut_167,
    "x_check_comments__mutmut_168": x_check_comments__mutmut_168,
    "x_check_comments__mutmut_169": x_check_comments__mutmut_169,
    "x_check_comments__mutmut_170": x_check_comments__mutmut_170,
    "x_check_comments__mutmut_171": x_check_comments__mutmut_171,
    "x_check_comments__mutmut_172": x_check_comments__mutmut_172,
    "x_check_comments__mutmut_173": x_check_comments__mutmut_173,
    "x_check_comments__mutmut_174": x_check_comments__mutmut_174,
    "x_check_comments__mutmut_175": x_check_comments__mutmut_175,
    "x_check_comments__mutmut_176": x_check_comments__mutmut_176,
    "x_check_comments__mutmut_177": x_check_comments__mutmut_177,
    "x_check_comments__mutmut_178": x_check_comments__mutmut_178,
    "x_check_comments__mutmut_179": x_check_comments__mutmut_179,
    "x_check_comments__mutmut_180": x_check_comments__mutmut_180,
    "x_check_comments__mutmut_181": x_check_comments__mutmut_181,
    "x_check_comments__mutmut_182": x_check_comments__mutmut_182,
    "x_check_comments__mutmut_183": x_check_comments__mutmut_183,
    "x_check_comments__mutmut_184": x_check_comments__mutmut_184,
    "x_check_comments__mutmut_185": x_check_comments__mutmut_185,
    "x_check_comments__mutmut_186": x_check_comments__mutmut_186,
    "x_check_comments__mutmut_187": x_check_comments__mutmut_187,
    "x_check_comments__mutmut_188": x_check_comments__mutmut_188,
    "x_check_comments__mutmut_189": x_check_comments__mutmut_189,
    "x_check_comments__mutmut_190": x_check_comments__mutmut_190,
    "x_check_comments__mutmut_191": x_check_comments__mutmut_191,
    "x_check_comments__mutmut_192": x_check_comments__mutmut_192,
    "x_check_comments__mutmut_193": x_check_comments__mutmut_193,
    "x_check_comments__mutmut_194": x_check_comments__mutmut_194,
    "x_check_comments__mutmut_195": x_check_comments__mutmut_195,
    "x_check_comments__mutmut_196": x_check_comments__mutmut_196,
    "x_check_comments__mutmut_197": x_check_comments__mutmut_197,
    "x_check_comments__mutmut_198": x_check_comments__mutmut_198,
    "x_check_comments__mutmut_199": x_check_comments__mutmut_199,
    "x_check_comments__mutmut_200": x_check_comments__mutmut_200,
    "x_check_comments__mutmut_201": x_check_comments__mutmut_201,
    "x_check_comments__mutmut_202": x_check_comments__mutmut_202,
    "x_check_comments__mutmut_203": x_check_comments__mutmut_203,
    "x_check_comments__mutmut_204": x_check_comments__mutmut_204,
    "x_check_comments__mutmut_205": x_check_comments__mutmut_205,
    "x_check_comments__mutmut_206": x_check_comments__mutmut_206,
    "x_check_comments__mutmut_207": x_check_comments__mutmut_207,
    "x_check_comments__mutmut_208": x_check_comments__mutmut_208,
    "x_check_comments__mutmut_209": x_check_comments__mutmut_209,
    "x_check_comments__mutmut_210": x_check_comments__mutmut_210,
    "x_check_comments__mutmut_211": x_check_comments__mutmut_211,
    "x_check_comments__mutmut_212": x_check_comments__mutmut_212,
    "x_check_comments__mutmut_213": x_check_comments__mutmut_213,
    "x_check_comments__mutmut_214": x_check_comments__mutmut_214,
    "x_check_comments__mutmut_215": x_check_comments__mutmut_215,
    "x_check_comments__mutmut_216": x_check_comments__mutmut_216,
    "x_check_comments__mutmut_217": x_check_comments__mutmut_217,
    "x_check_comments__mutmut_218": x_check_comments__mutmut_218,
    "x_check_comments__mutmut_219": x_check_comments__mutmut_219,
    "x_check_comments__mutmut_220": x_check_comments__mutmut_220,
    "x_check_comments__mutmut_221": x_check_comments__mutmut_221,
    "x_check_comments__mutmut_222": x_check_comments__mutmut_222,
    "x_check_comments__mutmut_223": x_check_comments__mutmut_223,
    "x_check_comments__mutmut_224": x_check_comments__mutmut_224,
    "x_check_comments__mutmut_225": x_check_comments__mutmut_225,
    "x_check_comments__mutmut_226": x_check_comments__mutmut_226,
    "x_check_comments__mutmut_227": x_check_comments__mutmut_227,
    "x_check_comments__mutmut_228": x_check_comments__mutmut_228,
    "x_check_comments__mutmut_229": x_check_comments__mutmut_229,
    "x_check_comments__mutmut_230": x_check_comments__mutmut_230,
    "x_check_comments__mutmut_231": x_check_comments__mutmut_231,
    "x_check_comments__mutmut_232": x_check_comments__mutmut_232,
    "x_check_comments__mutmut_233": x_check_comments__mutmut_233,
    "x_check_comments__mutmut_234": x_check_comments__mutmut_234,
    "x_check_comments__mutmut_235": x_check_comments__mutmut_235,
    "x_check_comments__mutmut_236": x_check_comments__mutmut_236,
    "x_check_comments__mutmut_237": x_check_comments__mutmut_237,
    "x_check_comments__mutmut_238": x_check_comments__mutmut_238,
    "x_check_comments__mutmut_239": x_check_comments__mutmut_239,
    "x_check_comments__mutmut_240": x_check_comments__mutmut_240,
    "x_check_comments__mutmut_241": x_check_comments__mutmut_241,
    "x_check_comments__mutmut_242": x_check_comments__mutmut_242,
    "x_check_comments__mutmut_243": x_check_comments__mutmut_243,
    "x_check_comments__mutmut_244": x_check_comments__mutmut_244,
}


def check_comments(*args, **kwargs):
    result = _mutmut_trampoline(
        x_check_comments__mutmut_orig, x_check_comments__mutmut_mutants, args, kwargs
    )
    return result


check_comments.__signature__ = _mutmut_signature(x_check_comments__mutmut_orig)
x_check_comments__mutmut_orig.__name__ = "x_check_comments"
