# This workflow runs on a schedule to automatically check for new releases from a source repository.
# If a new version is found, it patches a file, creates a new release in this repository,
# posts a notification to Reddit, and commits the updated state.
# If no new version is found, the workflow exits gracefully with a success status.
name: '[Release] Check for Updates, Patch, and Post'

on:
  workflow_dispatch:
  schedule:
    - cron: '5 * * * *'

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

jobs:
  check_and_patch:
    name: 1. Check for New Version
    runs-on: ubuntu-latest
    outputs:
      new_version_found: ${{ steps.compare_versions.outputs.new_version_found }}
      new_version: ${{ steps.compare_versions.outputs.version }}
      direct_download_url: ${{ steps.create_and_upload.outputs.direct_url }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Read config.json into Environment
        id: config
        uses: antifree/json-to-variables@v1
        with:
          filename: 'config.json'

      - name: Sanity Check Configuration
        run: |
          set -e
          if [[ "${{ env.github_botRepo }}" == "YourUsername/BitBot" || "${{ env.github_botRepo }}" != "${{ github.repository }}" ]]; then
            echo "::error::Configuration error: 'github.botRepo' in config.json must be set to '${{ github.repository }}'."
            exit 1
          fi
          echo "Configuration check passed."

      - name: Fetch and Parse Source Version
        id: source_release
        run: |
          set -eo pipefail
          RELEASE_DATA=$(curl -fsSL -H "Accept: application/vnd.github+json" -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${{ env.github_sourceRepo }}/releases/latest")
          
          VERSION=$(echo "$RELEASE_DATA" | jq -r .body | grep -oP '(?<=v)\d+\.\d+\.\d+')
          if [[ -z "$VERSION" ]]; then
            echo "::error::Could not parse version from the release body."
            exit 1
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Get Latest Bot Release Tag
        id: bot_release
        run: |
          set -eo pipefail
          TAG=$(curl -fsSL "https://api.github.com/repos/${{ env.github_botRepo }}/releases/latest" | jq -r .tag_name)
          # Handle case where no releases exist yet
          if [[ "$TAG" == "null" ]]; then
            TAG=""
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Compare Versions and Set Execution Flag
        id: compare_versions
        run: |
          set -e
          SOURCE_VERSION="v${{ steps.source_release.outputs.version }}"
          BOT_VERSION="${{ steps.bot_release.outputs.tag }}"

          if [[ "$SOURCE_VERSION" == "$BOT_VERSION" ]]; then
            echo "No new version found. Current version is $BOT_VERSION. Workflow will stop gracefully."
            echo "new_version_found=false" >> $GITHUB_OUTPUT
          else
            echo "New version $SOURCE_VERSION found (current is $BOT_VERSION). Proceeding with release."
            echo "new_version_found=true" >> $GITHUB_OUTPUT
            echo "version=${{ steps.source_release.outputs.version }}" >> $GITHUB_OUTPUT
          fi

      - name: Download, Process, and Create Release
        if: steps.compare_versions.outputs.new_version_found == 'true'
        id: create_and_upload
        run: |
          set -eo pipefail
          VERSION="${{ steps.compare_versions.outputs.version }}"
          ASSET_NAME="${{ env.github_assetFileName }}"

          echo "--- 1. Downloading and Processing Asset ---"
          mkdir -p ./dist
          ASSET_ID=$(curl -fsSL -H "Accept: application/vnd.github+json" "https://api.github.com/repos/${{ env.github_sourceRepo }}/releases/latest" | jq --arg NAME "$ASSET_NAME" '.assets[] | select(.name == $NAME) | .id')
          if [[ -z "$ASSET_ID" || "$ASSET_ID" == "null" ]]; then
            echo "::error::Could not find asset named '$ASSET_NAME'."
            exit 1
          fi
          curl -fsSL -J -H "Accept: application/octet-stream" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -o "./dist/original_$ASSET_NAME" "https://api.github.com/repos/${{ env.github_sourceRepo }}/releases/assets/$ASSET_ID"
          node process_vars.js "./dist/original_$ASSET_NAME" "./dist/$ASSET_NAME"

          echo "--- 2. Creating Git Tag ---"
          TAG_NAME="v$VERSION"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin "$TAG_NAME"

          echo "--- 3. Creating GitHub Release and Uploading Asset ---"
          RELEASE_TITLE=$(echo "${{ env.messages_releaseTitle }}" | sed "s/{{asset_name}}/$ASSET_NAME/g" | sed "s/{{version}}/$VERSION/g")
          RELEASE_BODY=$(echo "${{ env.messages_releaseDescription }}" | sed "s/{{asset_name}}/$ASSET_NAME/g")
          CREATE_DATA=$(printf '{"tag_name": "%s", "name": "%s", "body": "%s"}' "$TAG_NAME" "$RELEASE_TITLE" "$RELEASE_BODY")
          
          RELEASE_RESPONSE=$(curl -fsSL -X POST -H "Accept: application/vnd.github+json" -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -d "$CREATE_DATA" "https://api.github.com/repos/${{ env.github_botRepo }}/releases")
          UPLOAD_URL=$(echo "$RELEASE_RESPONSE" | jq -r .upload_url)
          
          ASSET_PATH="./dist/$ASSET_NAME"
          UPLOAD_URL_TEMPLATE=$(echo "$UPLOAD_URL" | sed 's/{?name,label}//')
          curl -fsSL -X POST -H "Accept: application/vnd.github+json" -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -H "Content-Type: application/octet-stream" --data-binary "@$ASSET_PATH" "$UPLOAD_URL_TEMPLATE?name=$ASSET_NAME"
          
          echo "direct_url=https://github.com/${{ env.github_botRepo }}/releases/download/$TAG_NAME/$ASSET_NAME" >> $GITHUB_OUTPUT

  post_and_finalize:
    name: 2. Post Notification and Commit State
    needs: check_and_patch
    if: needs.check_and_patch.outputs.new_version_found == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install Python Dependencies
        run: pip install -r requirements.txt

      - name: Post to Reddit and Update State File
        env:
          REDDIT_CLIENT_ID: ${{ secrets.REDDIT_CLIENT_ID }}
          REDDIT_CLIENT_SECRET: ${{ secrets.REDDIT_CLIENT_SECRET }}
          REDDIT_USERNAME: ${{ secrets.REDDIT_USERNAME }}
          REDDIT_PASSWORD: ${{ secrets.REDDIT_PASSWORD }}
          REDDIT_USER_AGENT: ${{ secrets.REDDIT_USER_AGENT }}
        run: python post_to_reddit.py "${{ needs.check_and_patch.outputs.new_version }}" "${{ needs.check_and_patch.outputs.direct_download_url }}"

      - name: Generate Commit Message
        id: commit_msg
        env:
          VERSION: ${{ needs.check_and_patch.outputs.new_version }}
        run: |
          COMMIT_MSG_TEMPLATE=$(jq -r '.messages.newPostCommit' config.json)
          COMMIT_MSG=$(echo "$COMMIT_MSG_TEMPLATE" | sed "s/{{version}}/$VERSION/g")
          echo "message=$COMMIT_MSG" >> $GITHUB_OUTPUT
      
      - name: Commit and Push State File
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: ${{ steps.commit_msg.outputs.message }}
          file_pattern: "bot_state.json"