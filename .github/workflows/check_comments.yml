name: '[Pulse] Check Reddit Comments'

on:
  workflow_dispatch:
  schedule:
    - cron: '*/1 * * * *' # Runs every minute

env:
  BOT_REPO: "YourUsername/BitBot" # <-- IMPORTANT: CHANGE to YourUsername/BitBot
  STATE_FILE: "bot_state.json"

jobs:
  pulse_check:
    name: Adaptive Comment Check
    runs-on: ubuntu-latest
    permissions: { contents: write } # Needed to commit state changes
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v4
        with: { python-version: '3.10' }
      - name: Install Dependencies
        run: pip install -r requirements.txt
      - name: Run Adaptive Comment Checker Script
        env:
          REDDIT_CLIENT_ID: ${{ secrets.REDDIT_CLIENT_ID }}
          REDDIT_CLIENT_SECRET: ${{ secrets.REDDIT_CLIENT_SECRET }}
          REDDIT_USERNAME: ${{ secrets.REDDIT_USERNAME }}
          REDDIT_PASSWORD: ${{ secrets.REDDIT_PASSWORD }}
          REDDIT_USER_AGENT: "BitBot Comment Monitor v2.0"
        run: |
          python -c '
import os, json, sys, re, requests, praw
from datetime import datetime, timezone, timedelta

# --- Configuration ---
STATE_FILE = os.environ["STATE_FILE"]
GITHUB_REPO = os.environ["BOT_REPO"]
INITIAL_INTERVAL_S, MAX_INTERVAL_S, INTERVAL_INCREMENT_S = 300, 3600, 300

def get_latest_post_id():
    api_url = f"https://api.github.com/repos/{GITHUB_REPO}/releases/latest"
    try:
        assets = requests.get(api_url).json().get("assets", [])
        for asset in assets:
            if asset["name"] == "latest_post_id.txt":
                return requests.get(asset["browser_download_url"]).text.strip()
    except Exception as e: print(f"Could not get post ID from GitHub: {e}")
    return None

def load_state():
    with open(STATE_FILE, "r") as f: return json.load(f)

def save_state(data):
    with open(STATE_FILE, "w") as f: json.dump(data, f, indent=2)

# --- Main Logic ---
print("--- Starting Pulse Check ---")
state = load_state()
now = datetime.now(timezone.utc)

latest_id_from_release = get_latest_post_id()
if latest_id_from_release and latest_id_from_release != state["postId"]:
    print(f"New post detected! Resetting state for post ID: {latest_id_from_release}")
    state = {"postId": latest_id_from_release, "lastCheckTimestamp": "2024-01-01T00:00:00Z", "currentIntervalSeconds": INITIAL_INTERVAL_S, "lastCommentCount": 0}

if not state["postId"] or state["postId"] == "null":
    print("No active post ID. Exiting pulse."); sys.exit(0)

last_check = datetime.fromisoformat(state["lastCheckTimestamp"])
next_check = last_check + timedelta(seconds=state["currentIntervalSeconds"])

if now < next_check:
    print(f"Not time yet. Next check at {next_check.isoformat()}. Exiting pulse."); sys.exit(0)

print(f"Time for a real check! Last check was at {last_check.isoformat()}.")

try:
    reddit = praw.Reddit(client_id=os.environ["REDDIT_CLIENT_ID"], client_secret=os.environ["REDDIT_CLIENT_SECRET"], user_agent=os.environ["REDDIT_USER_AGENT"], username=os.environ["REDDIT_USERNAME"], password=os.environ["REDDIT_PASSWORD"])
    submission = reddit.submission(id=state["postId"])
    submission.comments.replace_more(limit=0)
    comments = submission.comments.list()
    
    not_working_count = sum(1 for c in comments if re.search(r"not working|broken|doesnt work", c.body, re.I))
    new_status = "Potentially Not Working" if not_working_count >= 2 else "Working"
    print(f"Determined status: {new_status} (based on {not_working_count} comments)")
    status_line = f"**Current Status (based on community feedback):** {new_status}"
    
    if status_line not in submission.selftext:
        submission.edit(body=re.sub(r"(\*\*Current Status.*\*\*).*$", status_line, submission.selftext))
        print("Post status updated.")
    else:
        print("Status is already correct.")

    if len(comments) > state["lastCommentCount"]:
        print("New comments found! Resetting check interval.")
        state["currentIntervalSeconds"] = INITIAL_INTERVAL_S
    else:
        print("No new comments. Increasing check interval.")
        state["currentIntervalSeconds"] = min(MAX_INTERVAL_S, state["currentIntervalSeconds"] + INTERVAL_INCREMENT_S)
    state["lastCommentCount"] = len(comments)

except Exception as e: print(f"::error::An error occurred during check: {e}")
finally:
    state["lastCheckTimestamp"] = now.isoformat()
    save_state(state)
    print(f"State file updated for next run. Next interval: {state['currentIntervalSeconds']}s")
'
      - name: Commit and Push State File
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(bot): update comment checker state"
          file_pattern: ${{ env.STATE_FILE }}
