"""This module handles the encryption and decryption of the asset file.\n\nIt is a direct port of the original process_vars.js script.\n"""\n\nimport base64\nfrom pathlib import Path\nfrom typing import Dict, Union\n\nfrom .logging import get_logger\n\nlogger = get_logger(__name__)\n\n# --- Constants ---\nDEFAULT_CIPHER_KEY = "com.wtfapps.apollo16"\nB64_NET_BOOLEAN_TRUE = (\n    "AAEAAAD/////AQAAAAAAAAAEAQAAAA5TeXN0ZW0uQm9vbGVhbgEAAAAHbV92YWx1ZQABAQs="\n)\nB64_NET_BOOLEAN_FALSE = (\n    "AAEAAAD/////AQAAAAAAAAAEAQAAAA5TeXN0ZW0uQm9vbGVhbgEAAAAHbV92YWx1ZQABAAw="\n)\nOBF_CHAR_MAP = {\n    0x61: 0x7A,\n    0x62: 0x6D,\n    0x63: 0x79,\n    0x64: 0x6C,\n    0x65: 0x78,\n    0x66: 0x6B,\n    0x67: 0x77,\n    0x68: 0x6A,\n    0x69: 0x76,\n    0x6A: 0x69,\n    0x6B: 0x75,\n    0x6C: 0x68,\n    0x6D: 0x74,\n    0x6E: 0x67,\n    0x6F: 0x73,\n    0x70: 0x66,\n    0x71: 0x72,\n    0x72: 0x65,\n    0x73: 0x71,\n    0x74: 0x64,\n    0x75: 0x70,\n    0x76: 0x63,\n    0x77: 0x6F,\n    0x78: 0x62,\n    0x79: 0x6E,\n    0x7A: 0x61,\n}\n\n\ndef get_obfuscated_key(key: str) -> str:\n    """Apply a simple character substitution obfuscation to the cipher key.\n\n    Args:\n        key: The input key.\n\n    Returns:\n        The obfuscated key.\n    """\n    o_key = ""\n    for char in key.lower():\n        code = ord(char)\n        o_key += chr(OBF_CHAR_MAP.get(code, code))\n    return o_key\n\n\ndef xor_and_b64_encode(text: str, key: str) -> str:\n    """Perform an XOR operation on text and then Base64 encodes the result.\n\n    Args:\n        text: The input text.\n        key: The XOR key.\n\n    Returns:\n        The Base64-encoded, XORed result.\n    """\n    if not key:\n        return ""\n    xor_result = "".join(\n        [chr(ord(c) ^ ord(key[i % len(key)])) for i, c in enumerate(text)]\n    )\n    return base64.b64encode(xor_result.encode("latin1")).decode("utf-8")\n\n\ndef b64_decode_and_xor(b64: str, key: str) -> str:\n    """Decode a Base64 string and then performs an XOR operation.\n\n    Args:\n        b64: The Base64-encoded input string.\n        key: The XOR key.\n\n    Returns:\n        The decoded and XORed result.\n    """\n    if not key:\n        return ""\n    decoded = base64.b64decode(b64.encode("utf-8")).decode("latin1")\n    return "".join(\n        [chr(ord(c) ^ ord(key[i % len(key)])) for i, c in enumerate(decoded)]\n    )\n\n\ndef decrypt(encrypted_content: str, obfuscated_key: str) -> Dict[str, Union[bool, str]]:\n    """Decrypt the content of the asset file into a dictionary.\n\n    Args:\n        encrypted_content: The raw, encrypted file content.\n        obfuscated_key: The obfuscated key for decryption.\n\n    Returns:\n        A map of decrypted keys to their decrypted values.\n    """\n    item_map: Dict[str, Union[bool, str]] = {}\n    for line in encrypted_content.splitlines():\n        if not line.strip():\n            continue\n        parts = line.split(":", 1)\n        if len(parts) != 2:\n            continue\n        enc_key, enc_val = parts\n        dec_key = b64_decode_and_xor(enc_key.strip(), obfuscated_key)\n        dec_val_b64 = b64_decode_and_xor(enc_val.strip(), obfuscated_key)\n\n        if dec_val_b64 == B64_NET_BOOLEAN_TRUE:\n            item_map[dec_key] = True\n        elif dec_val_b64 == B64_NET_BOOLEAN_FALSE:\n            item_map[dec_key] = False\n        else:\n            item_map[dec_key] = dec_val_b64\n    return item_map\n\n\ndef modify(data_object: Dict[str, Union[bool, str]]) -> Dict[str, Union[bool, str]]:\n    """Modify the decrypted data object by setting all boolean false values to true.\n\n    Args:\n        data_object: The decrypted data.\n\n    Returns:\n        The modified data object.\n    """\n    logger.info("Modifying data: Setting all boolean 'false' values to 'true'.")\n    for key, value in data_object.items():\n        if value is False:\n            data_object[key] = True\n    return data_object\n\n\ndef encrypt(data_object: Dict[str, Union[bool, str]], obfuscated_key: str) -> str:\n    """Re-encrypt the modified data object back into the file format.\n\n    Args:\n        data_object: The modified data object.\n        obfuscated_key: The key for encryption.\n\n    Returns:\n        The re-encrypted file content as a single string.\n    """\n    logger.info("Re-encrypting data...")\n    output_content = []\n    for key, value in data_object.items():\n        encrypted_key = xor_and_b64_encode(key, obfuscated_key)\n\n        if value is True:\n            value_to_serialize: Union[bool, str] = B64_NET_BOOLEAN_TRUE\n        elif value is False:\n            value_to_serialize = B64_NET_BOOLEAN_FALSE\n        else:\n            value_to_serialize = str(value)\n\n        encrypted_value = xor_and_b64_encode(str(value_to_serialize), obfuscated_key)\n        output_content.append(f"{encrypted_key}:{encrypted_value}")\n\n    return "\n".join(output_content)\n\n\ndef patch_file(input_path: str, output_path: str) -> None:\n    """Read, decrypt, modify, re-encrypt, and save a file.\n\n    Args:\n        input_path: The path to the input file.\n        output_path: The path to the output file.\n    """\n    logger.info("Processing file: %s", input_path)\n    obfuscated_key = get_obfuscated_key(DEFAULT_CIPHER_KEY)\n\n    input_file = Path(input_path)\n    with input_file.open("r", encoding="utf-8") as f:\n        encrypted_content = f.read()\n\n    decrypted_data = decrypt(encrypted_content, obfuscated_key)\n    modified_data = modify(decrypted_data)\n    re_encrypted_content = encrypt(modified_data, obfuscated_key)\n\n    output_file = Path(output_path)\n    with output_file.open("w", encoding="utf-8") as f:\n        f.write(re_encrypted_content)\n\n    logger.info("Successfully processed and saved patched file to: %s", output_path)\n